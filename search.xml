<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven系列(7)-pom元素说明]]></title>
    <url>%2F2017%2F09%2F23%2Fmaven-pom-xml%2F</url>
    <content type="text"><![CDATA[前言介绍pom文件 包含了pom的一些约束信息 1234&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;&lt;/project&gt; 12345&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 指定了当前pom的版本，它是必须的 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;/project&gt; 项目创建的包名 1&lt;groupId&gt;com.kimisme.app&lt;/groupId&gt; 项目名 1&lt;artifactId&gt;MavenTest&lt;/artifactId&gt; 版本号： shapshot快照 alpha内侧版本 beta公测 Release稳定 GA正式发布 1&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; 打包类型：默认jar。其他类型：war，zip，pom 1&lt;packaging&gt;jar&lt;/packaging&gt; 其他信息123456789101112&lt;!-- 项目的描述名；产生项目文档是才使用 --&gt;&lt;name&gt;&lt;/name&gt;&lt;!-- 项目的地址 --&gt;&lt;url&gt;&lt;/url&gt;&lt;!-- 项目的描述 --&gt;&lt;description&gt;&lt;/description&gt;&lt;!-- 开发人员列表 --&gt;&lt;developers&gt;&lt;/developers&gt;&lt;!-- 许可证信息，如用到了一些开源项目 --&gt;&lt;licenses&gt;&lt;/licenses&gt;&lt;!-- 组织信息 --&gt;&lt;organization&gt;&lt;/organization&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven系列(6)-Maven的生命周期]]></title>
    <url>%2F2017%2F09%2F23%2Fmaven-life-cycle%2F</url>
    <content type="text"><![CDATA[前言Maven的生命周期 三套生命周期Maven拥有三套相互独立的生命周期，它们分别为clean，default，site；每个生命周期包含一些阶段，这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段，用户和Maven最直接的交互方式就是调用这些生命周期阶段；]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven系列(5)-Eclipse集成]]></title>
    <url>%2F2017%2F09%2F23%2Fmaven-ide-integration%2F</url>
    <content type="text"><![CDATA[前言Maven与Eclipse的集成 M2Eclipse is the official Eclipse project for Maven integration for the Eclipse IDE. M2Eclipse 特性 Launching Maven builds from within Eclipse Dependency management for Eclipse build path based on Maven’s pom.xml Resolving Maven dependencies from the Eclipse workspace without installing to local Maven repository Automatic downloading of the required dependencies and sources from the remote Maven repositories Wizards for creating new Maven projects, pom.xml and to enable Maven support on existing projects Quick search for dependencies in remote Maven repositories Quick fixes in the Java editor for looking up required dependencies/jars by the class or package name Integration with other Eclipse tools, such as WTP, AJDT, Mylyn, Subclipse and others. M2E dynamically integrates with your Maven projects with Eclipse while you make changes in the IDE. As you change dependencies, or configurations of Maven plugins in your POMs M2E, will synchronize the Eclipse workspace with those changes. 安装从Eclipse Marketplace中搜索maven Maven配置Maven路径配置 Maven用户配置 Maven下载配置 创建Maven项目添加Maven项目 Next 选择maven-archetype-quickstart 添加坐标信息 项目截图 Maven项目导出Maven项目导入]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven系列(4)-Archetype插件]]></title>
    <url>%2F2017%2F09%2F23%2Fmaven-archetype-plugin%2F</url>
    <content type="text"><![CDATA[前言Maven自动生成项目骨架 The Archetype Plugin allows the user to create a Maven project from an existing template called an archetype. It also allows the user to create an archetype from an existing project. 插件Maven中有许多功能都是通过插件来提供的。maven-archetype-plugin就是Maven的一个插件 Archetype官网对该插件的介绍：http://maven.apache.org/archetype/maven-archetype-plugin/ archetype是Maven项目模板工具包，也就是一个模板工程。 Maven的Repository里提供了500~600个不同类型的archer types 使用执行命令 12cd maven03mvn archetype:generate -DgroupId=com.kimisme.app -DartifactId=maven03-app -Dversion=0.0.0 -DarchetypeArtifactId=maven-archetype-quickstart 输出以下内容，表示成功了 1234567891011121314151617181920[INFO] ----------------------------------------------------------------------------[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:1.0[INFO] ----------------------------------------------------------------------------[INFO] Parameter: basedir, Value: E:\maven03[INFO] Parameter: package, Value: com.kimisme.app[INFO] Parameter: groupId, Value: com.kimisme.app[INFO] Parameter: artifactId, Value: maven03-app[INFO] Parameter: packageName, Value: com.kimisme.app[INFO] Parameter: version, Value: 0.0.0[INFO] project created from Old (1.x) Archetype in dir: E:\maven03\maven03-app[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 01:12 min[INFO] Finished at: 2017-09-23T19:22:14+08:00[INFO] Final Memory: 15M/241M[INFO] ------------------------------------------------------------------------ 查看archetype生成的项目项目结构如下 1234/maven03-app/maven03-app/pom.xml/maven03-app/src/main/java/com/kimisme/app/App.java/maven03-app/src/test/java/com/kimisme/app/AppTest.java App.java 12345678910111213package com.kimisme.app;/** * Hello world! * */public class App &#123; public static void main( String[] args ) &#123; System.out.println( "Hello World!" ); &#125;&#125; AppTest.java 1234567891011121314151617181920212223242526272829303132333435363738package com.kimisme.app;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Unit test for simple App. */public class AppTest extends TestCase&#123; /** * Create the test case * * @param testName name of the test case */ public AppTest( String testName ) &#123; super( testName ); &#125; /** * @return the suite of tests being tested */ public static Test suite() &#123; return new TestSuite( AppTest.class ); &#125; /** * Rigourous Test :-) */ public void testApp() &#123; assertTrue( true ); &#125;&#125; pom.xml 123456789101112131415161718&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.kimisme.app&lt;/groupId&gt; &lt;artifactId&gt;maven03-app&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;name&gt;maven03-app&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven系列(3)-引入依赖]]></title>
    <url>%2F2017%2F09%2F23%2Fmaven-dependencies%2F</url>
    <content type="text"><![CDATA[前言Maven项目中依赖的使用 创建Maven项目项目结构如下 1234/maven02-app/maven02-app/pom.xml/maven02-app/src/main/java/com/kimisme/web/Home.java/maven02-app/src/test/java/com/kimisme/web/HomeTest.java Home.java 12345678package com.kimisme.web;import com.kimisme.app.HelloWorld;public class Home&#123; public void list()&#123; new HelloWorld().sayHello(); &#125;&#125; HomeTest.java 123456789package com.kimisme.web;import org.junit.*;import org.junit.Assert.*;public class HomeTest&#123; public void testList()&#123; Assert.assertEquals("Hello World",new Home().list()); &#125;&#125; pom.xml 12345678910111213141516171819202122232425&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 表示Maven的版本，4.0.0是固定的 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 表示项目的包名 --&gt; &lt;groupId&gt;com.kimisme.app&lt;/groupId&gt; &lt;!-- 表示模块名，项目名+模块名 --&gt; &lt;artifactId&gt;maven02-web&lt;/artifactId&gt; &lt;!-- 模块版本，以下是一个快照的版本 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 编译执行命令，出错了 12cd maven02mvn compile 错误提示是找不到com.kim.app这个包，那是因为我们还没引用 1234567891011121314151617181920[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project maven02-web: Compilation failure: Compilation failure:[ERROR] /E:/maven02/src/main/java/com/kimisme/web/Home.java:[4,8] 类List是公共的, 应在名为 List.java 的文件中声明[ERROR] /E:/maven02/src/main/java/com/kimisme/web/Home.java:[2,23] 程序包com.kimisme.app不存在[ERROR] /E:/maven02/src/main/java/com/kimisme/web/Home.java:[6,21] 找不到符号[ERROR] 符号: 类 HelloWorld[ERROR] 位置: 类 com.kimisme.web.List[ERROR] -&gt; [Help 1][ERROR][ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR][ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException 再次编译修改pom.xml 12345678910111213141516171819202122232425262728293031&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 表示Maven的版本，4.0.0是固定的 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 表示项目的包名 --&gt; &lt;groupId&gt;com.kimisme.app&lt;/groupId&gt; &lt;!-- 表示模块名，项目名+模块名 --&gt; &lt;artifactId&gt;maven02-web&lt;/artifactId&gt; &lt;!-- 模块版本，以下是一个快照的版本 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.kimisme.app&lt;/groupId&gt; &lt;!-- 表示模块名，建议使用项目名 --&gt; &lt;artifactId&gt;maven01-app&lt;/artifactId&gt; &lt;!-- 项目版本，以下是一个快照的版本 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 执行命令mvn compile，出现以下结果 12345678[INFO] Compiling 1 source file to E:\maven02\target\classes[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 1.125 s[INFO] Finished at: 2017-09-23T17:55:37+08:00[INFO] Final Memory: 14M/229M[INFO] ------------------------------------------------------------------------]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven系列(2)-常用命令]]></title>
    <url>%2F2017%2F09%2F23%2Fmaven-common-cmd%2F</url>
    <content type="text"><![CDATA[前言介绍Maven的常用命令。 Maven项目的默认结构123--src/main/java/package--src/test/java/package--src/resouces src/main/java：用于存放Java源代码 src/main/resource：用于存放资源文件 src/test/java：用于存放测试代码 创建Maven项目目录项目结构如下 1234/maven01-app/maven01-app/pom.xml/maven01-app/src/main/java/com/kimisme/app/HelloWorld.java/maven01-app/src/test/java/com/kimisme/app/HelloWorldTest.java HelloWorld.java 1234567package com.kimisme.app;public class HelloWorld&#123; public String sayHello()&#123; return "Hello World"; &#125;&#125; HelloWorldTest.java 1234567891011package com.kimisme.app;import org.junit.*;import org.junit.Assert.*;public class HelloWorldTest&#123; @Test public void testHello()&#123; Assert.assertEquals("Hello World",new HelloWorld().sayHello()); &#125;&#125; pom.xml 1234567891011121314151617181920212223&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 表示Maven的版本，4.0.0是固定的 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 表示项目的包名 --&gt; &lt;groupId&gt;com.kimisme.app&lt;/groupId&gt; &lt;!-- 表示模块名，项目名+模块名 --&gt; &lt;artifactId&gt;maven01-app&lt;/artifactId&gt; &lt;!-- 模块版本，以下是一个快照的版本 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编译执行命令,会在项目根目录生成名为target/classes的文件夹 12cd maven01mvn compile 输出以下结果表示执行成功 12345678[INFO] Compiling 1 source file to E:\maven01\target\classes[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.818 s[INFO] Finished at: 2017-09-23T17:03:09+08:00[INFO] Final Memory: 15M/134M[INFO] ------------------------------------------------------------------------ 测试执行命令,会在项目根目录生成名为target/test-classes的文件夹 12cd maven01mvn test 输出以下结果表示执行成功 1234567891011121314151617------------------------------------------------------- T E S T S-------------------------------------------------------Running com.kimisme.app.HelloWorldTestTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.044 secResults :Tests run: 1, Failures: 0, Errors: 0, Skipped: 0[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 4.645 s[INFO] Finished at: 2017-09-23T17:11:09+08:00[INFO] Final Memory: 19M/236M[INFO] ------------------------------------------------------------------------ 打包执行命令,会在项目根目录生成名为target/*.jar的文件 12cd maven01mvn package 输出以下结果表示执行成功 12345678[INFO] Building jar: E:\maven01\target\maven01-app-0.0.1-SNAPSHOT.jar[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.513 s[INFO] Finished at: 2017-09-23T17:31:43+08:00[INFO] Final Memory: 11M/166M[INFO] ------------------------------------------------------------------------ 清理执行命令,会在删除文件夹target 12cd maven01mvn clean 输出以下结果表示执行成功 123456789101112131415[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building maven01-app 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO][INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ maven01-app ---[INFO] Deleting E:\maven01\target[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.304 s[INFO] Finished at: 2017-09-23T17:34:04+08:00[INFO] Final Memory: 5M/180M[INFO] ------------------------------------------------------------------------ 安装执行命令,会同时执行编译，测试，打包命令 12cd maven01mvn install 输出以下结果表示执行成功 123456789[INFO] Installing E:\maven01\pom.xml to C:\**\Maven\repository\com\kimisme\app\maven01-app\0.0.1-SNAPSHOT\maven01-app-0.0.1-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.977 s[INFO] Finished at: 2017-09-23T17:35:34+08:00[INFO] Final Memory: 20M/184M[INFO] ------------------------------------------------------------------------]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven系列(1)-Maven安装及配置]]></title>
    <url>%2F2017%2F09%2F23%2Fmaven-install-and-config%2F</url>
    <content type="text"><![CDATA[前言Maven安装及介绍 Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project’s build, reporting and documentation from a central piece of information. 简介 Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具； 下载地址官网地址：http://maven.apache.org Maven目录结构介绍 bin：包含mvn的运行脚本 boot：包含一个类加载器框架 conf：包含配置文件 lib：包含mvn使用的类库 配置变量 添加系系统变量：M2_HOME=&quot;指向Maven的安装的根目录&quot; 在Path中添加引用：%M2_HOME%\bin; 验证配置：mvc-v]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo系列(3)-Next主题配置]]></title>
    <url>%2F2017%2F09%2F23%2Fhexo-next-theme-config%2F</url>
    <content type="text"><![CDATA[前言个性化个人博客 完整基本信息设置网站介绍 修改站点配置文件 1234567# Sitetitle: Think Differentsubtitle:description:author: Kimismelanguage: zh-Hanstimezone: 设置网址 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://kimisme.comroot: /permalink: :year/:month/:day/:title/permalink_defaults: 设置头像修改站点配置文件 1avatar: http://om9xacvdp.bkt.clouddn.com/blog-self-logo.jpg 设置RSS安装插件 执行命令 1npm install --save hexo-generator-feed 修改站点配置文件 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/plugins: hexo-generate-feed 修改主题配置文件 1rss: /atom.xml 编译hexo，在/public目录下生产atom.xml文件 1hexo g 添加标签页面执行命令，会生成/source/tags/index.md文件 12$ cd myblog$ hexo new page tags 修改主题配置文件 123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 修改/source/tags/index.md 123title: 标签date: 2014-12-22 12:39:04type: "tags" 添加分类页面执行命令，会生成/source/categories/index.md文件 12$ cd myblog$ hexo new page categories 修改主题配置文件 123456menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive 修改/source/categories/index.md 1234title: 分类测试文章categories: Testingtype: "categories"comments: false 添加关于我页面执行命令，会生成/source/about/index.md文件 12$ cd myblog$ hexo new page about 设置代码高亮主题修改主题配置文件 1highlight_theme: normal 侧边栏社交链接修改主题配置文件 123social: GitHub: https://github.com/kimisme || github 简书: http://www.jianshu.com/u/d511eb68dcbe || heartbeat 腾讯公益404页面添加/source/404.html，内容如下 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 站点建立时间修改主题配置文件 1since: 2016 显示访问量修改主题配置文件 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer: 修改文章内内链接文本样式打开/themes/next/source/css/_common/components/post/post.styl，在末尾添加如下代码 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 文章加密访问本地搜索执行命令 1npm install hexo-generator-searchdb --save 修改站点配置文件 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件 123# Local searchlocal_search: enable: true 修改代码块的样式打开/themes/next/source/css/_custom/custom.styl，并添加 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo系列(2)-部署GitHub]]></title>
    <url>%2F2017%2F09%2F23%2Fhexo-deploy-github%2F</url>
    <content type="text"><![CDATA[前言博客部署GitHub以及绑定个人域名 博客部署到GitHub安装插件 12$ npm install hexo-deployer-git --savenpm install hexo-util --save 设置部署路径 修改站点配置文件 1234deploy: type: git repo: git@github.com:Kimisme/kimisme.github.io.git branch: master 部署 12$ hexo g$ hexo d 绑定个性域名添加CNAME 添加/public/CNAME文件 1kimisme.com 部署 12$ hexo g$ hexo d 获取博客IP地址 解析域名]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo系列(1)-建立博客]]></title>
    <url>%2F2017%2F09%2F23%2Fhexo-create-a-blog-system%2F</url>
    <content type="text"><![CDATA[前言使用Hexo创建个人博客 建立Hexo博客安装Hexo 1$ npm install -g hexo -cli 初始化Hexo 123hexo init myblogcd myblognpm myblog 下载主题 12cd mybloggit clone https://github.com/Kimisme/hexoblog-next-theme.git themes/next 启用主题 修改站点配置文件 1theme: next 验证主题 1$ hexo s --debug 主题设定 修改主题配置文件 1scheme: Mist 设置语言 修改站点配置文件 1language: zh-Hans]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寡妇的油]]></title>
    <url>%2F2017%2F07%2F23%2Fgrace-the-oil-of-the-widow%2F</url>
    <content type="text"><![CDATA[前言本文是今天教会分享的一段经文。本文包含三部分内容：1.经文故事介绍；2.我们从经文看到了什么信息；3.经文要传达的信息 经文摘录以利沙帮助一个穷寡妇(王下4:1-7) 有一个先知门徒的妻，哀求以利沙说：“你仆人我丈夫死了，他敬畏耶和华是你所知道的。现在有债主来，要取我两个儿子作奴仆。”以利沙问她说：“我可以为你做甚么呢？你告诉我，你家里有甚么？”她说：“婢女家中除了一瓶油之外，没有甚么。”以利沙说：“你去，向你众邻舍借空器皿，不要少借。回到家里，关上门，你和你儿子在里面，将油倒在所有的器皿里，倒满了的放在一边。”于是，妇人离开以利沙去了，关上门，自己和儿子在里面。儿子把器皿拿来，她就倒油，器皿都满了。她对儿子说：“再给我拿器皿来。”儿子说：“再没有器皿了。”油就止住了。妇人去告诉神人。神人说：“你去卖油还债，所剩的，你和你儿子可以靠著度日。” 经文关键词债主，寡妇，以利沙，寡妇的儿子，空器皿，油 经文讲了什么故事债主逼迫穷寡妇儿子做奴仆，以利沙显神迹帮助。 我们看到的信息债主在人身处困境时，并没有怜悯，而是咄咄逼人。 寡妇相信他丈夫的神会帮助她。 以利沙在人向他寻求帮助时，并没有拒绝，而是表现出慈爱。 寡妇对以利沙的话并没有怀疑。 以利沙显神迹使一瓶油倒满了每个的空器皿并有余。 寡妇不仅走出了困境，还靠着多余的油度日。 经文传达的信息神所给予我们的远比我们渴求的多的多 妇人只想他的儿子不被债主抓走，但神不仅使寡妇还了债，还靠着买油度日。 在软弱中寻求神 妇人在患难中寻求神的帮助。 做为神的代言人以利沙依然寻求神的帮助。]]></content>
      <categories>
        <category>Grace</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[成为自我的教练]]></title>
    <url>%2F2017%2F07%2F22%2Fdedao-be-your-own-coach%2F</url>
    <content type="text"><![CDATA[前言这是古典老师分享的一篇文章的部分学习记录。原文名为《自我教练：打赢你的“内在”之战》 摘录 传统的教学方法里人们过多希望做一个标准的动作，却常常忽略了最重要的“目标”。 比如演讲的时候，我们常常满脑子在想该做的10件事，不该做的事，和背好的稿子，就是忘记了其实演讲要吸引的是台下的人注意。 比如写文章时，我们经常花大量时间在文章样式怎么吸引人，怎么分段落，寻找好看的图片，确忘记了写文章就是将一个观点表达清楚。 每一项比赛都是由两个部分构成，外在比赛和内在比赛。 所谓的外在比赛，就是要战胜对手，克服障碍，达成必要的外在目标。 “内在”里，选手也在进行比赛。注意力不集中、过度紧张、缺乏自信、无端自责… 所有的高手都是“内在”比赛的人。 聚集目标、排除内在干扰 表现=潜能-干扰 performance=potential-inerfere P=p-p** 我们要做的事情，就是降低干扰。“放松而专注”，干扰主要来自于两个，自我评价(就是内在弹幕)以及目标不清。 反例 和朋友打桌球的时候，每当他出杆的时候，我就说，教教我吧。你出杆的时候，到底是怎么发力的？是先用腰部带动手，还是手和腰一起用力？是呼气还是吸气？是先瞄准再调，还是调完再瞄准？ 经过我的干扰，他都没赢过。第一，他目标开始模糊，要赢又要教。第二，他的内心开始自我评价—其实谁知道是先呼气还是吸气呢？ 今日思考题 今天你最想拿到的一个结果是什么？如果今晚睡觉前你觉得一整天都没有白过，那是因为白天做了什么？ 当好自己的教练，它会让你持续聚焦目标，排除干扰，方式而专注地发货潜能。]]></content>
      <categories>
        <category>得到</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cheat-sheet-visual-studio-shortcut-key]]></title>
    <url>%2F2017%2F06%2F28%2Fcheat-sheet-visual-studio-shortcut-key%2F</url>
    <content type="text"><![CDATA[前言 快捷键代码格式化 第一步：选中代码第二步：Ctrl+K，Ctrl+F]]></content>
  </entry>
  <entry>
    <title><![CDATA[《图解HTTP》读书笔记]]></title>
    <url>%2F2017%2F06%2F13%2Fbook-read-record-graphic-http%2F</url>
    <content type="text"><![CDATA[前言文本是《图解HTTP》的读书笔记，持续更新中。边读边记。 第1章 了解Web及网络基础协议(protocol) 计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由那一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的一切都需要一种规则。我们就把这种规则称为协议。 TCP三次握手(three-way handshaking) 发送端首先发送一个带SYN标志的数据包给对方。 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息 发送端再回传一个带ACK标志的数据包，代表“握手”结束 一次请求过程 发送端访问http://hackr.jp/xss/Web页面 请求先到达DNS服务，将域名解析成对应的IP地址20x.189.105.112 客户端再根据应用层的HTTP协议，生成针对目标Web服务器的HTTP请求报文 为了方便通信，传输层的TCP协议会将请求报文分割成报文段 紧接着网络层的IP协议会搜索对方的地址，一边中转一边传送 最后报文到达与处理连接网络的硬件部分链路层 在接收端依次经过链路层，网络层,传输层,应用层 接受端将请求的处理结果也同样利用TCP/IP通信协议向用户进行回转 第2章 简单的HTTP协议请求报文与响应报文 12GET /index.htm HTTP/1.1Host: hackr.jp 请求报文由请求方法、请求URI，客户端的协议版本，可选的请求首字段和内容实体构成。 12HTTP/1.1 200 OKContent-Length: 362 响应报文由接收端的协议版本、状态码，用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。 HTTP的一些特性 HTTP是一种无状态协议，即不保存之前一切或响应报文的信息。为了实现保持状态的功能，引入了Cookie技术 HTTP/1.0每进行一次通信，紧要进行一次TCP连接和断开，为了解决TCP连接问题，在HTTP/1.1中引入了持久连接。它的特点是任意一端没有明确提出断开连接，则保持TCP连接状态 以前请求后需等待并受到响应，才能发送下一个请求。持久连接使多数请求以管道化方式发送成为可能。即能够做到同事并行发送多个请求，而不需要一个接一个地等待响应 使用Cookie的状态管理 客户端发送请求 12GET /reader/ HTTP/1.1Host:hackr.jp 接收端响应报文 123HTTP/1.1 200 OKServer: ApacheSet-Cookie: sid=1342077140226724 客户端再次发送请求 123GET /image/ HTTP/1.1Host:hackr.jpCookie: sid=1342077140226724 第3章 报文内的HTTP信息]]></content>
      <categories>
        <category>BookRecord</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[record-oop]]></title>
    <url>%2F2017%2F06%2F12%2Frecord-oop%2F</url>
    <content type="text"><![CDATA[前言记录面向对象开发的一些话。 把类的职责划分好。把领域的问题划分到合适的类当中去，让这些类协作起来。让代码尽可能对接口进行编程。多用组合，而不是继承。发现变化并且封装变化。 在概念层次上，对象是一组责任，这个对象负责什么。在规约层次上，对象是一组可以被其他对象或者自己调用的方法。在实现层次上，对象是代码和数据 面向对象设计原则单一职责原则 （SRP）开闭原则 (OCP)Liskov 替换原则 (LSP)接口隔离原则 (ISP)依赖倒置原则 (DIP) SOLID：写出优雅代码的关键所在]]></content>
  </entry>
  <entry>
    <title><![CDATA[我从哪里来，要往哪里去]]></title>
    <url>%2F2017%2F06%2F11%2Fgrace-where-did-i-come-from%2F</url>
    <content type="text"><![CDATA[前言今天磐石堂牧师分享的主题是，我从哪里来，要往哪里去，然后就有了这篇随记。 正文我从哪里来，是温州吗，还是杭电它们都不是我的起点我已经在杭州生活了6年早已忘记，忘记了最初的来路线回头，早已看不清，最初的那个自己我有一个梦想成为一名见证人，影响周围的人但如今，我已习惯了妥协生活的安逸，失去了目标单调的工作，缺少了本该有的激情我已习惯用左手工作我有一个梦想在象棋领域有所成就从村子，到学校，到县城，一路的赢棋我曾以为这是上天赐给我的天赋手游毁了这一切几次的输气，开始怀疑我有一个梦想成为一名作家读书时，每当作文被当成范文总有莫名的成就感有段时间，每天数着新浪中的博文的阅读数如今字都写不来了现在我有一个梦想成为某个领域的权威]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java系列-Synchronized与Volatile的原理]]></title>
    <url>%2F2017%2F06%2F10%2Fjava-basic-synchronized-volatile%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍在多线程开发中，对于并发读取数据的一种处理方式。 可见性可见性是说操作结果其他线程是否可见 可见性，是针对线程来说的，即一个线程对共享变量值的修改，能够及时地被其他线程看到。 如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。 比如有一个整型变量number=1，线程A做了number+=1的写操作，那么线程B在读取number的时候，就应该是2，而不应该还是1. 导致共享变量在线程间不可见的原因 线程的交叉执行（原子性） 重排序结合线程交叉执行（原子性） 共享变量更新后的值没有在工作内存与主内存间及时更新（可见性） 原子性一个操作是否可分割 字面上理解，原子是世界上最小的单位，具有不可分割的特性。在代码层面上可以理解为，一个操作不能再被分割成更小的颗粒度。比如：a++，它实际上是两个步骤：首先做加法temp=a+1，然后再赋值a=temp。所以a++不是一个原子操作。如果一个操作是原子操作，那么我们就称它具有原子性。原子性可以理解为 重排序什么是重排序 为了是提升编译器和处理的执行效率，而对程序代码做了先后顺序调整。 为什么要重排序 指令重排序是编译器或处理器为了提高程序性能而做的优化。主要包括以下几方面： 编译器优化的重排序(编译器优化) 指令集并行重排序(处理器优化) 内存系统的重排序(处理器优化) 重排序例子一 如果代码顺序如下 12int number=1;int result=0; 重排序后，执行顺序可能是 12int result=0;int number=1; 重排序例子二 以下代码也是可以被重排序的 123if (ready) &#123; result = number * 3;&#125; 因为number的运算与ready是没有数据依赖关系的，他可以被重排序成以下代码 1234int temp = number*3;if(ready)&#123; result = temp;&#125; 重排序带来的问题 重排序不会给单线程带来内存可见性问题；多线程中程序交错执行时，重排序可能会造成内存可见性问题。 as-if-serial语义 这里就引出了一个概念，代码重排序后，执行的结果的变化。我们称这个约束为as-if-serial，即无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致。 Java编译器、运行时和处理器都会保证Java在单线程下遵循as-if-serial语义 Java内存模型Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的细节。 所有的变量都是存储在主内存中的 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成 Synchronized代码清单完整代码如下，然后我们再一步步分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SynchronizedDemo &#123; // 共享变量 private boolean ready = false; private int result = 0; private int number = 1; // 写操作 public void write() &#123; ready = true; // 1.1 //为了测试，让写操作稍微延迟一点// try &#123;// Thread.sleep(1000);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; number = 2; // 1.2 &#125; // 读操作 public void read() &#123; if (ready) &#123; // 2.1 result = number * 3; // 2.2 &#125; System.out.println("result的值为：" + result); &#125; // 内部线程类 private class ReadWriteThread extends Thread &#123; // 根据构造方法中传入的flag参数，确定线程执行读操作还是写操作 private boolean flag; public ReadWriteThread(boolean flag) &#123; this.flag = flag; &#125; @Override public void run() &#123; if (flag) &#123; // 构造方法中传入true，执行写操作 write(); &#125; else &#123; // 构造方法中传入false，执行读操作 read(); &#125; &#125; &#125; public static void main(String[] args) &#123; SynchronizedDemo synDemo = new SynchronizedDemo(); // 启动线程执行写操作 synDemo.new ReadWriteThread(true).start(); // 启动线程执行读操作 synDemo.new ReadWriteThread(false).start(); &#125;&#125; 在SynchronizedDemo中有3个共享变量。有两个操作：写操作和读操作。还有一个线程类：它的功能比较简单就是，通过构造函数传入一个boolean来执行不同的方法。如果为true就执行写操作，如果是false就执行读操作。 几种结果因为写和读是再两个线程里面，那么就涉及到先后顺序了。结果一：如果执行顺序是ready=true-&gt;number=2-&gt;if(ready){}-&gt;result=number*3，那么输出result的结果就是6结果二：如果执行顺序是ready=true-&gt;if(ready){}-&gt;result=number*3-&gt;number=2，那么输出的result结果就是3结果三：如果执行顺序是number=2-&gt;if(ready){}-&gt;result=number*3-&gt;ready=true。因为此时ready=false,那么输出的结果就是0 解决可见性问题我们修改写方法 1234567891011// 写操作 public synchronized void write() &#123; ready = true; // 1.1 //为了测试，让写操作稍微延迟一点 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; number = 2; // 1.2 &#125; 再修改读方法 1234567// 读操作 public synchronized void read() &#123; if (ready) &#123; // 2.1 result = number * 3; // 2.2 &#125; System.out.println("result的值为：" + result); &#125; 我们再次运行程序，不管运行多少次，结果都是6 Synchronized的实现过程 获得互斥锁 清空工作内存 从主内存拷贝变量的最新副本到工作内存 执行代码 将更改后的共享变量的值刷新到主内存 释放互斥锁 VolatileVolatile如何实现内存可见性 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令 对volatile变量执行读操作时，会在读操作前加入一条load屏障指令 加入这两条执行的结果就是：volatile变量在每次被线程访问时，都被迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存中。这样任何时刻，不同的线程总能看到该变量的最新值。 代码清单12345678910111213141516171819202122232425262728293031323334353637public class VolatileDemo &#123; //共享变量 private volatile int number=0; //自增 public void increase()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.number++; &#125; //获取共享变量 public int getNumber()&#123; return this.number; &#125; public static void main(String[] args) &#123; final VolatileDemo volDemo=new VolatileDemo(); for(int i=0;i&lt;500;i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; volDemo.increase(); &#125; &#125;).start(); &#125; while(Thread.activeCount()&gt;1)&#123; Thread.yield(); &#125; System.out.println("number="+volDemo.getNumber()); &#125;&#125; 运行上面的程序，输出的结果是不确定的。我们得出了一个结论 volatile能够保证变量的可见性 volatile不能保证符合操作的原子性 要保证符合操作的原子性，我们可以这么操作 方式一：使用aynchronized保证变量在线程中的原子性 123456789101112public void increase()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; synchronized (this) &#123; this.number++; &#125; &#125; 方式二：用ReentrantLock实现变量在线程中的原子性 引入Lock 1private Lock lock=new ReentrantLock(); 开始加锁 123456789101112131415public void increase()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; lock.lock(); try&#123; this.number++; &#125;finally&#123; lock.unlock(); &#125; &#125;]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#程序破解]]></title>
    <url>%2F2017%2F06%2F10%2Fdot-net-app-crack%2F</url>
    <content type="text"><![CDATA[前言今天在整理磁盘的时候，看到了一个文件，想起来是之前玩破解时留下的。本来想网上找一款软件来写写，最后偷懒还是自己写个简单的应用程序自娱自乐好了。 准备工具首先是电脑安装了宇宙最强IDE(Visual Studio)，它在本次的作用仅仅只是为了编译一个.Net应用程序，来模拟我们在百度上下载到的一款有C#编写的应用程序(当然网上肯定不会有这种商业软件，他们大部分都是经过代码混淆，软件加壳)。然后我们需要准备一款.Net的反汇编工具(Graywolf)，用来查看源码(源码不一定看的到，IL语言肯定是可以的) 我们的测试软件我们用宇宙最强IDE创建一个Winform程序，然后拖一个按钮，编写以下事件 123456789101112131415161718namespace WinApp&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void btnAlert_Click(object sender, EventArgs e) &#123; for (int i = 1; i &lt;= 3; i++) &#123; MessageBox.Show(i+"你好啊"); &#125; &#125; &#125;&#125; 运行我们的测试程序它的功能很简单，就是点击按钮，会弹出小窗口1你好啊，2你好啊,3你好啊 我们的目的我们要让这个应用程序中的按钮被点击的时候，弹出5次Hello World 开始反编译打开我们的反编译工具(GrayWolf)，并导入我们的应用程序(WinApp.exe) 左边框框里的是.Net平台的中间语言IL，这是.Net实现跨语言，跨平台的关键 我们要找的就是按钮，一个可以弹出信息的按钮，我们一眼就看到了 好的，接下来我们就开始修改代码，修改之后记得保存 再次运行我们保存的文件 结语破解.Net程序和破解Java程序是类似的。在.Net中存在一种叫IL语言的语言，在Java中也同样存在一种叫字节码 的东西。它们都不过是保存在文本里面的十六进制罢了，既然CLR和JVM可以读懂这些，我们就又办法修改它们。比如你的同学开发了一款管理系统桌面程序，但是要登录。那么你就可以用小技巧，让它登录失去意义。]]></content>
      <categories>
        <category>DotNet</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA备忘录]]></title>
    <url>%2F2017%2F06%2F10%2Fcheat-sheet-intellij-ieda%2F</url>
    <content type="text"><![CDATA[前言最近准备入手IDEA玩玩，因为之前有过一段时间热衷于使用PyCharm开发Python，后来有段时间没写Python现在又忘记差不多了。这次准备边学习，边记录。 主题配置Sublime-Monokai主题下载主题包 https://github.com/y3sh/Intellij-Colors-Sublime-Monokai 导入主题包 配置主题包 护眼主题设置字体大小 设置背景色 其他主题http://www.easycolor.cc/index.php/Index/exlist/tid/1 优化配置显示行号 取消拼音检查 关闭自动保存 未保存显示星号 开启序列号检测 修改资源文件的编码 修改快捷键 隐藏没用的文件 代码提示不区分大小写 自动import类型 常用快捷键参考文章 http://blog.csdn.net/dc_726/article/details/42784275 创建main()方法 方式一：输入main，然后按快捷键Ctrl+J方式二：输入psvm 快速System.out.println() 输入sout 快速for(int i;i&lt;2;i++)循环 输入fori 快速重构 选中需要重构的代码块，然后按快捷键Ctrl+Shift+Alt+T 快速重命名 选中需要重命名的变量或方法名，然后按快捷键Shift+F6 代码格式化 方法一：按快捷键Ctrl+Shift+Alt+L方法二：按快捷键Ctrl+Shift+A，然后输入reformat code 删除某一行 按快捷键Ctrl+Y 代码注释 方式一：快捷键Ctrl+/方式二：快捷键Ctrl+Shift+/ 快速解决 快捷键Alt+Enter]]></content>
      <categories>
        <category>Cheat-Sheet</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[metronic-overview]]></title>
    <url>%2F2017%2F06%2F07%2Fmetronic-overview%2F</url>
    <content type="text"><![CDATA[参考文章https://segmentfault.com/a/1190000006673582]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux-shell-function]]></title>
    <url>%2F2017%2F06%2F07%2Flinux-shell-function%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[linux-shell-if-else]]></title>
    <url>%2F2017%2F06%2F07%2Flinux-shell-if-else%2F</url>
    <content type="text"><![CDATA[算术运算使用expr 注意expr运算符之间要有空格 要想取运算的结果需要用反引号 123456[root@localhost scripts]# expr 1 + 23[root@localhost scripts]# echo `expr 2 + 3`5[root@localhost scripts]# s=`expr 2 + 3`[root@localhost scripts]# echo $s 使用(()) 每一个运算都要用括号包起来 要想取运算结果，需要用$引用 12345678[root@localhost scripts]# echo $((2+3))5[root@localhost scripts]# echo $(((2+3)*4))20[root@localhost scripts]# count=1[root@localhost scripts]# ((count++))[root@localhost scripts]# echo $count2 使用$[] 12345[root@localhost scripts]# echo $[1+2]3[root@localhost scripts]# a=$[1+2][root@localhost scripts]# echo $a3 if语句语法格式 每条语句前面的空格是可以去掉的，当然为了阅读良好还是保留 [ condition ]，在中括号也是一个命令，所以在与变量之间要有空格 1234567891011121314[root@localhost scripts]# vi welcome.sh then then#!/bin/bashread -p "please input your name:" NAMEif [ $NAME = root ] then echo "hello $&#123;NAME&#125;,welcom !" elif [ $NAME = jack ] then echo "hello $&#123;NAME&#125;,my goodfriend !" else echo "who are you"fi true与false [ 1=2 ]，只要condition是非空的字符串，都返回true [ 1 = 2 ]，只有运算符两端有空格，它才表示运算，此时返回false 123456[root@localhost scripts]# if [ a=b ];then echo ok;else echo nook;fiok[root@localhost scripts]# if [ a = b ];then echo ok;else echo nook;finook[root@localhost scripts]# if [ ];then echo ok;else echo nook;finook 短路(三元运算符) 语法格式：[condition] &amp;&amp; echo ok || echo nook。条件满足执行&amp;&amp;后面的语句；条件不满足，执行||后面的语句 条件的组合 []不支持&amp;&amp;，||符号，可以借助于-a，-o [[]]支持&amp;&amp;，||符号 12345678[root@localhost scripts]# if [ a = b -a b = b ];then echo ok;else echo nook;finook[root@localhost scripts]# if [ a = b -o b = b ];then echo ok;else echo nook;fiok[root@localhost scripts]# if [[ a = b &amp;&amp; b = b ]];then echo ok;else echo nook;finook[root@localhost scripts]# if [[ a = b || b = b ]];then echo ok;else echo nook;fiok 字符串比较 = 字符串是否相等 != 字符串是否不等 -n 字符串长度是否为0 -z 字符串长度是否为0 12345678[root@localhost scripts]# if [ 'aa' = 'bb' ];then echo ok;else echo notok;finotok[root@localhost scripts]# if [ 'aa' != 'bb' ];then echo ok;else echo notok;fiok[root@localhost scripts]# if [ -n 'aa' ];then echo ok;else echo notok;fiok[root@localhost scripts]# if [ -z 'aa' ];then echo ok;else echo notok;finotok 整数比较 -lt表示小于 -le表示小于或等于 -eq表示等于 -gt表示大于 -ge表示大于或等于 -ne表示不等于 12[root@localhost scripts]# if [ 1 -le 5 ];then echo ok;else echo notok;fiok 文件判断 -d表示是否为目录 -f表示是否为文件 -e表示是否存在 12345678910[root@localhost scripts]# if [ -d /bin ];then echo ok;else echo notok;fiok[root@localhost scripts]# if [ -d /bin2 ];then echo ok;else echo notok;finotok[root@localhost scripts]# if [ -f /bin/ls ];then echo ok;else echo notok;fiok[root@localhost scripts]# if [ -f /bin/l2s ];then echo ok;else echo notok;finotok[root@localhost scripts]# if [ -e /bin/ls ];then echo ok;else echo notok;fiok]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot-JPA连接数据库]]></title>
    <url>%2F2017%2F06%2F07%2Fspringboot-db-jpa%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍在springboot中如何使用JPA操作数据库 项目结构12345678910111213--src/main/java----com.easy------Program.java----com.easy.controllers------HomeController.java------StudentController.java----com.easy.dao------StudentDao.java----com.easy.pojo------Student.java--src/main/resources----application.properties--build.gradle 引入依赖1234compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.4.2.RELEASE'compile group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.4.2.RELEASE'compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.38'compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa', version: '1.4.2.RELEASE' 编写实体层123456789@Entity@Table(name="t_student3")public class Student &#123; @Id @GeneratedValue private int id; private String name; private int age; private Date createTime; 编写数据层123public interface StudentDao extends JpaRepository&lt;Student,Integer&gt;&#123; &#125; 编写控制器层123456789101112@RestController@RequestMapping("/stu")public class StudentController &#123; @Autowired private StudentDao studentDao; @RequestMapping("/list") public List&lt;Student&gt;getStudents()&#123; return studentDao.findAll(); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-JDBC连接数据库]]></title>
    <url>%2F2017%2F06%2F07%2Fspringboot-db-jdbc%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍在SpringBoot中如何用jdbc连接数据库 项目结构12345678910111213--src/main/java----com.easy------Program.java----com.easy.controllers------HomeController.java------StudentController.java----com.easy.pojo------Student.java----com.easy.service------StudentService.java--src/main/resources----application.properties--build.gradle 引入依赖1234compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.4.2.RELEASE'compile group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.4.2.RELEASE'compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.38'compile group: 'org.springframework.boot', name: 'spring-boot-starter-jdbc', version: '1.4.2.RELEASE' 配置JDBC连接1234spring.datasource.url=jdbc:mysql://127.0.0.1:3306/tempdb?useSSL=truespring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver 编写我们的实体类12345public class Student &#123; private int id; private String name; private int age; private Date createTime; 编写Service层12345678910111213141516171819202122@Servicepublic class StudentService &#123; @Autowired private JdbcTemplate jdbcTemplate; public List&lt;Student&gt; getList()&#123; String sql="select ID,Name,Age,CreateTime from t_student"; return (List&lt;Student&gt;)jdbcTemplate.query(sql, new RowMapper&lt;Student&gt;()&#123; @Override public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Student stu=new Student(); stu.setId(rs.getInt("ID")); stu.setName(rs.getString("Name")); stu.setAge(rs.getInt("Age")); stu.setCreateTime(rs.getDate("CreateTime")); return stu; &#125; &#125;); &#125;&#125; 编写控制层123456789101112@RestController@RequestMapping("/stu")public class StudentController &#123; @Autowired private StudentService studentService; @RequestMapping("/list") public List&lt;Student&gt;getStudents()&#123; return studentService.getList(); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系列-变量定义]]></title>
    <url>%2F2017%2F06%2F06%2Flinux-shell-thread-relation%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍shell中的变量 系统变量可以用set命令查看系统变量 12[root@localhost ~]# set | grep PWDPWD=/root 用户自定义变量变量的赋值 变量=值（等号两侧不能有空格） 12345[root@localhost ~]# arg=hello[root@localhost ~]# arg2="hello world"[root@localhost ~]# arg3='hello world'[root@localhost ~]# arg4="$arg world"[root@localhost ~]# arg5='$arg world' 变量的使用 单引号会将变量的引用转义，比如$arg 12345678910[root@localhost ~]# echo $arghello[root@localhost ~]# echo $&#123;arg2&#125;shello worlds[root@localhost ~]# arg4="$arg world"[root@localhost ~]# echo $arg4hello world[root@localhost ~]# arg5='$arg world'[root@localhost ~]# echo $arg5$arg world 撤销变量 1[root@localhost ~]# unset arg 变量的提权 1export a=aaa 操作练习编写第一个shell1234[root@localhost scripts]# vi a.sh#!/bin/basha="a in a.sh"echo $a 编写第二个shell 12345[root@localhost scripts]# vi b.sh#!/bin/bashb="b in b.sh"echo $becho $a 给shell添加执行的权限 12[root@localhost scripts]# chmod +x a.sh[root@localhost scripts]# chmod +x b.sh 执行shell 123[root@localhost scripts]# sh a.shin a.sh---aaain b.sh--- 因为每次调用sh都会开启一个新的进程。a.sh和b.sh是在不同的进程里，进程之间是不能共享变量的。 方式一：使用export 修改a.sh 12345[root@localhost scripts]# vi a.sh#!/bin/bashexport a=aaaecho "in a.sh---"$ash b.sh 执行shell 123[root@localhost scripts]# sh a.shin a.sh---aaain b.sh---aaa 因为b.sh是在a.sh所在进程的一个子进程。如果给变量添加export，那么它的子进程空间就可以共享变量。但是父进程还是不能共享[root@localhost scripts]# echo $a 方式二：使用source 修改a.sh 12345[root@localhost scripts]# vi a.sh#!/bin/basha=aaaecho &quot;in a.sh---&quot;$asource /root/scripts/b.sh 执行shell 123[root@localhost scripts]# sh a.shin a.sh---aaain b.sh---aaa 如果使用source的话，执行b.sh的时候就不会在开启一个新的进程。而是b.sh也在a.sh所在的进程空间中执行 source的另一种写法，就是使用点号 修改a.sh 12345[root@localhost scripts]# vi a.sh#!/bin/basha=aaaecho &quot;in a.sh---&quot;$a. /root/scripts/b.sh]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot-启动加载数据]]></title>
    <url>%2F2017%2F06%2F06%2Fspringboot-boot-load-data%2F</url>
    <content type="text"><![CDATA[前言当我们的项目在启动的时候需要加载一些数据或做一些事，这个时候就我们要怎么做。 项目结构123456789--src/main/java----com.easy------Program.java----com.easy.controllers------HomeController.java----com.easy.core------MyStartupRunner1.java------MyStartupRunner2.java--build.gradle 编写我们的服务第一个服务 123456789@Component@Order(value=2)public class MyStartupRunner1 implements CommandLineRunner&#123; @Override public void run(String... args) throws Exception &#123; System.out.println("MyStartupRunner1..."); &#125;&#125; 第二个服务 12345678910@Component@Order(value=1)public class MyStartupRunner2 implements CommandLineRunner&#123; @Override public void run(String... args) throws Exception &#123; System.out.println("MyStartupRunner2..."); &#125;&#125; @Order注解的执行优先级是按value值从小到大顺序 参考文章http://blog.csdn.net/catoop/article/details/50501710]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-拦截器]]></title>
    <url>%2F2017%2F06%2F06%2Fspringboot-interceptor%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍下拦截器在SpringBoot中的使用 操作步骤 创建自定义的拦截器(实现HandlerInterceptor接口) 创建Web容器(继承WebMvcConfigurerAdapter类)，并将我们的拦截器addInterceptors到容器 项目结构1234567891011--src/main/java----com.easy------Program.java----com.easy.controllers------HomeController.java----com.easy.interceptor------MyInterceptor.java------MyWebAppConfigurer.java----com.easy.web.servlet------BServlet.java--build.gradle 定义我们的拦截器执行过程：请求到达—&gt;preHandle—&gt;Controller中的方法—&gt;postHandle—&gt;afterCompletion 123456789101112131415161718192021public class MyInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("preHandle"); return true;//只有返回true才会往下执行 &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("afterCompletion"); &#125;&#125; 创建Web容器12345678910111213@Configurationpublic class MyWebAppConfigurer extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; //多个拦截器组成一个拦截器链 //addPathPatterns()用于添加拦截规则 //excludePathPatterns()用于排除拦截 registry.addInterceptor(new MyInterceptor()).addPathPatterns("/*"); super.addInterceptors(registry); &#125;&#125; 测试在浏览器中输入http://localhost:8080/BServlet不触发拦截，为什么呢？ 只有经过DispatcherServlet 的请求，才会走拦截器链，我们自定义的Servlet 请求是不会被拦截的 参考文章http://blog.csdn.net/catoop/article/details/50501696]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-Servlet]]></title>
    <url>%2F2017%2F06%2F06%2Fspringboot-servlet-filter-listener%2F</url>
    <content type="text"><![CDATA[前言JavaWeb的三大组件：Servlet,Filter,Listener。本文主要介绍在SpringBoot如何使用 两种方式在spring boot中添加自己的Servlet有两种方法，代码注册Servlet和注解自动注册。 一、代码注册通过ServletRegistrationBean、 FilterRegistrationBean 和 ServletListenerRegistrationBean 获得控制。也可以通过实现 ServletContextInitializer 接口直接注册。 二、在 SpringBootApplication 上使用@ServletComponentScan 注解后，Servlet、Filter、Listener 可以直接通过 @WebServlet、@WebFilter、@WebListener 注解自动注册，无需其他代码。 使用代码注册项目结构123456789101112--src/main/java----com.easy------Program.java----com.easy.controllers------HomeController.java----com.easy.web.filter------AFilter.java----com.easy.web.listener------AListener.java----com.easy.web.servlet------AServlet.java--build.gradle 自定义我们组件自定义我们的Servet 123456public class AServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().append("Get Request:"+req.getRequestURL()); &#125;&#125; 自定义我们的Filter 12345678910111213141516171819public class AFilter implements Filter&#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("初始化过滤器"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("执行过滤操作"); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println("销户过滤器"); &#125;&#125; 自定义我们的Listener 123456789101112public class AListener implements ServletContextListener&#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println("初始化监听器"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println("销户监听器"); &#125;&#125; 对组件进行注册1234567891011121314151617181920212223242526272829@SpringBootApplicationpublic class Program &#123; public static void main(String[] args) &#123; SpringApplication.run(Program.class, args); &#125; @Bean public ServletRegistrationBean servletRegistrationBean()&#123; ServletRegistrationBean registration=new ServletRegistrationBean(); registration.setServlet(new AServlet()); registration.addUrlMappings("/AServlet/*"); return registration; &#125; @Bean public FilterRegistrationBean filterRegistrationBean()&#123; FilterRegistrationBean registration=new FilterRegistrationBean(); registration.setFilter(new AFilter()); registration.addUrlPatterns("/*"); return registration; &#125; @Bean public ServletListenerRegistrationBean servletListenerRegistrationBean()&#123; ServletListenerRegistrationBean registration=new ServletListenerRegistrationBean(); registration.setListener(new AListener()); return registration; &#125;&#125; 当我们在浏览器中输入http://localhost:8080/AServlet/Jack，会输出Get Request:http://localhost:8080/AServlet/Jack 使用注解自动注册项目结构123456789101112--src/main/java----com.easy------Program.java----com.easy.controllers------HomeController.java----com.easy.web.filter------BFilter.java----com.easy.web.listener------BListener.java----com.easy.web.servlet------BServlet.java--build.gradle 自定义我们的组件自定义我们的Servlet 1234567@WebServlet(name="BServlet",urlPatterns="/BServlet/*")public class BServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().append("Get Request:"+req.getRequestURL()); &#125;&#125; 自定义我们的Filter 1234567891011121314151617181920@WebFilter(urlPatterns="/*",filterName="BFilter")public class BFilter implements Filter&#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("初始化过滤器"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("执行过滤操作"); chain.doFilter(request, response); &#125; @Override public void destroy() &#123; System.out.println("销户过滤器"); &#125;&#125; 自定义我们的Listener 12345678910111213@WebListenerpublic class BListener implements ServletContextListener&#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println("初始化监听器"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println("销户监听器"); &#125;&#125; 注册我们的组件1234567@SpringBootApplication@ServletComponentScanpublic class Program &#123; public static void main(String[] args) &#123; SpringApplication.run(Program.class, args); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-动态代理]]></title>
    <url>%2F2017%2F06%2F06%2Fjava-basic-aop%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍Java中的两种动态代理方式 JDK动态代理编写代理类编写我们需要代理的类，JDK动态代理，代理类必须依赖接口 12345public interface AccountService &#123; public void transfer(String fromAccount, String toAccount, int ammount); public void query(String accountId);&#125; 代理类具体的实现 123456789101112public class AccountServiceImpl implements AccountService&#123; @Override public void transfer(String fromAccount, String toAccount, int ammount) &#123; System.out.println("Transfer " + ammount + " from " + fromAccount + " to " + toAccount ); &#125; @Override public void query(String accountId) &#123; System.out.println("Query account id:" +accountId); &#125;&#125; 编写切面类切面类可以理解为我们想要给代理类增强的功能，比如给业务层增加事务功能 12345678public class Transaction &#123; public void beginTx()&#123; System.out.println("Begin transaction"); &#125; public void commitTx()&#123; System.out.println("Commit transaction"); &#125;&#125; 测试类我们需要三个类型：类加载器，代理类实现的接口，handler 123456789101112131415161718192021222324public static void main(String[] args) &#123; final AccountService accountService = new AccountServiceImpl(); final Transaction tran = new Transaction(); ClassLoader loader = TestApp.class.getClassLoader(); InvocationHandler handler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object obj = null; if (method.getName().equals("transfer")) &#123; tran.beginTx(); obj = method.invoke(accountService, args); tran.commitTx(); &#125; else &#123; obj = method.invoke(accountService, args); &#125; return obj; &#125; &#125;; AccountService proxyService = (AccountService) Proxy.newProxyInstance(loader, new Class[] &#123; AccountService.class &#125;, handler); proxyService.transfer("Jack", "Rose", 520); proxyService.query("Rose");&#125; cglib代理引入Jar包使用cglib代理，我们需要引入第三方jar包 1compile group: 'cglib', name: 'cglib', version: '2.2.2' 设置目标类我们的目标类不需要实现任何接口 12345678910public class AccountServiceImpl&#123; public void transfer(String fromAccount, String toAccount, int ammount) &#123; System.out.println("Transfer " + ammount + " from " + fromAccount + " to " + toAccount ); &#125; public void query(String accountId) &#123; System.out.println("Query account id:" +accountId); &#125;&#125; 设置切面类12345678public class Transaction &#123; public void beginTx()&#123; System.out.println("Begin transaction"); &#125; public void commitTx()&#123; System.out.println("Commit transaction"); &#125;&#125; 获取代理类使用cglib代理，有个核心类就是Enhancer 12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; //1.目标类 final AccountServiceImpl accountService=new AccountServiceImpl(); //2.切面类 final Transaction tran=new Transaction(); //3.代理类 //3.1核心类 Enhancer enhancer=new Enhancer(); //3.2确定父类 enhancer.setSuperclass(accountService.getClass()); //3.3设置回调函数 enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object obj=null; if(method.getName().equals("transfer"))&#123; tran.beginTx(); obj=method.invoke(accountService, args); tran.commitTx(); &#125;else&#123; obj=method.invoke(accountService, args); &#125; return obj; &#125; &#125;); //3.4创建代理类 AccountServiceImpl proxyService=(AccountServiceImpl)enhancer.create(); proxyService.transfer("Rose", "Jack", 520); proxyService.query("Rose");&#125;]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm-awesome]]></title>
    <url>%2F2017%2F06%2F05%2Fjvm-awesome%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础-泛型]]></title>
    <url>%2F2017%2F06%2F05%2Fjava-basic-generics%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-序列化]]></title>
    <url>%2F2017%2F06%2F05%2Fjava-basic-serialization%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍序列化的使用 什么是序列化将对象和它的元数据(比如对象的类名和它的属性名称)存储为一种特殊的二进制格式，这个过程称为序列化。这个相反的过程被称为反序列化。 序列化的应用场景 对象持久化：将对象的状态存储在一种永久的持久性机制中，比如数据库 对象远程存储：将对象发送到另一台计算机或另一个系统 Serializable接口实现序列化的第一步是使对象能够使用该机制。Serializable是一个空接口。 123public class User1 implements Serializable&#123; private String name; private int age; 对User对象进行序列化和去序列化 123456789101112131415161718public static void main(String[] args) throws Exception &#123; //初始化对象 User1 user = new User1(); user.setName("jack"); user.setAge(20); System.out.println(user);//User1 [name=jack, age=20] //序列化：对象序列化到文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile")); oos.writeObject(user); oos.close(); //去序列化：从文件中读取对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream("tempFile")); User1 newUser = (User1) ois.readObject(); ois.close(); System.out.println(newUser);//User1 [name=jack, age=20]&#125; Externalizable接口除了Serializable 之外，java中还提供了另一个序列化接口Externalizable。Externalizable接口有两个方法 1234public interface Externalizable extends java.io.Serializable &#123; void writeExternal(ObjectOutput out) throws IOException; void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;&#125; 需要序列化的对象，需要实现Externalizable接口，并重写实现的两个新方法。 123456789101112131415161718public static void main(String[] args) throws Exception &#123; //初始化对象 User1 user = new User1(); user.setName("jack"); user.setAge(20); System.out.println(user);//User1 [name=jack, age=20] //序列化：对象序列化到文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile")); oos.writeObject(user); oos.close(); //去序列化：从文件中读取对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream("tempFile")); User1 newUser = (User1) ois.readObject(); ois.close(); System.out.println(newUser);//User1 [name=jack, age=20]&#125; 开始序列化和去序列化测试 12345678910111213141516public static void main(String[] args) throws Exception &#123; //初始化对象 User2 user=new User2(); user.setName("rose"); user.setAge(18); System.out.println(user);//User2 [name=rose, age=18] //序列化：将对象序列化到文件 ObjectOutputStream oos =new ObjectOutputStream(new FileOutputStream("tempFile2")); oos.writeObject(user); //去序列化：从文件中读取对象 ObjectInputStream ois=new ObjectInputStream(new FileInputStream("tempFile2")); User2 newInstance=(User2)ois.readObject(); System.out.println(newInstance);//User2 [name=rose, age=18]&#125; 序列化约束 要想将父类对象也序列化，就需要让父类也实现Serializable 接口 在变量声明前加上transient关键字，可以阻止该变量被序列化到文件中 序列化ID虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致。 123public class User3 implements Serializable&#123; //默认是1L private static final long serialVersionUID=1L; 参考文章 https://www.ibm.com/developerworks/cn/java/j-perry-java-serialization/index.html https://www.ibm.com/developerworks/cn/java/j-lo-serial/ http://www.hollischuang.com/archives/1150 http://www.hollischuang.com/archives/1140#What%20Serializable%20Did]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-quartz]]></title>
    <url>%2F2017%2F05%2F29%2Fjava-basic-quartz%2F</url>
    <content type="text"><![CDATA[前言在项目中，我们经常会用到作用调度，这个时候我们就可以用这个Quartz框架了 什么是QuartzQuartz是一个完全由Java编写的开源作业调度框架，为在Java应用程序中进行作业调度提供了简单却强大的机制。Quartz允许开发人员根据时间间隔来调度作业。它实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。 使用Quartz我们在Gradle中引入以下地址 1compile group: 'org.quartz-scheduler', name: 'quartz', version: '2.2.1' 创建任务创建任务的方式比较简单，只要实现org.quarz.Job接口，并在execute()方法中写上具体的内容。 1234567public class HelloQuartzJob implements Job&#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.out.println(new Date()); &#125;&#125; context中获取调度计划和作业 12TriggerKey triggerKey = context.getTrigger().getKey();JobKey jobKey = context.getJobDetail().getKey(); 执行任务12345678910111213141516171819202122232425262728293031323334public class Program &#123; public static void main(String[] args) throws InterruptedException &#123; //获取调度器工厂 SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler =null; try&#123; //获取一个具体的调度器 scheduler=schedulerFactory.getScheduler(); //创建一个jobDetail JobDetail job=JobBuilder.newJob(HelloQuartzJob.class) .withIdentity("JobName","JobGroupName") .build(); //定义调度触发规则 Trigger trigger = TriggerBuilder.newTrigger() .withIdentity("CronTrigger1","CronTriggerGroup") .withSchedule(CronScheduleBuilder.cronSchedule("*/5 * * * * ?")) .startNow() .build(); //把作业和触发器注册到任务调度中 scheduler.scheduleJob(job,trigger); //启动调度 scheduler.start(); Thread.sleep(50000); //停止调度 scheduler.shutdown(); &#125;catch(SchedulerException e)&#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-mockito]]></title>
    <url>%2F2017%2F05%2F27%2Fjava-basic-mockito%2F</url>
    <content type="text"><![CDATA[前言 Gradle配置12compile group: 'org.mockito', name: 'mockito-all', version: '1.10.19'compile group: 'junit', name: 'junit', version: '4.12' 使用首先引入静态资源 12import static org.mockito.Mockito.*;import static org.junit.Assert.*; 验证行为12345678910public void verify_behaviour()&#123; //模拟创建一个List对象 List mock = mock(List.class); //使用mock的对象 mock.add(1); mock.clear(); //清空mock对象 //验证add(1)和clear()行为是否发生 verify(mock).add(1); verify(mock).clear(); &#125; 模拟我们所期望的结果12345678910public void when_thenReturn()&#123; //mock一个Iterator类 Iterator iterator = mock(Iterator.class); //预设当iterator调用next()时第一次返回hello，第n次都返回world when(iterator.next()).thenReturn("hello").thenReturn("world"); //使用mock的对象 String result = iterator.next() + " " + iterator.next() + " " + iterator.next(); //验证结果 assertEquals("hello world world",result); &#125; 模拟我们期待的异常12345678@Test(expected = IOException.class) public void when_thenThrow() throws IOException &#123; OutputStream outputStream = mock(OutputStream.class); OutputStreamWriter writer = new OutputStreamWriter(outputStream); //预设当流关闭时抛出异常 doThrow(new IOException()).when(outputStream).close(); outputStream.close(); &#125; 参数匹配1234567891011@Test public void with_arguments()&#123; Comparable comparable = mock(Comparable.class); //预设根据不同的参数返回不同的结果 when(comparable.compareTo("Test")).thenReturn(1); when(comparable.compareTo("Omg")).thenReturn(2); assertEquals(1, comparable.compareTo("Test")); assertEquals(2, comparable.compareTo("Omg")); //对于没有预设的情况会返回默认值 assertEquals(0, comparable.compareTo("Not stub")); &#125; 匹配自己想要的任意参数1234567891011121314151617public void with_unspecified_arguments()&#123; List list = mock(List.class); //匹配任意参数 when(list.get(anyInt())).thenReturn(1); when(list.contains(argThat(new IsValid()))).thenReturn(true); assertEquals(1, list.get(1)); assertEquals(1, list.get(999)); assertTrue(list.contains("1")); assertTrue(!list.contains("3")); &#125; private class IsValid extends ArgumentMatcher&lt;List&gt;&#123; @Override public boolean matches(Object o) &#123; return o.equals("1") || o.equals("2"); &#125; &#125; 需要注意的是如果你使用了参数匹配，那么所有的参数都必须通过matchers来匹配 12345678public void all_arguments_provided_by_matchers()&#123; Comparator comparator = mock(Comparator.class); comparator.compare("nihao","hello"); //如果你使用了参数匹配，那么所有的参数都必须通过matchers来匹配 verify(comparator).compare(anyString(),eq("hello")); //下面的为无效的参数匹配使用 //verify(comparator).compare(anyString(),"hello"); &#125; 验证确切的调用次数123456789101112131415161718192021222324public void verifying_number_of_invocations() &#123; List list = mock(List.class); list.add(1); list.add(2); list.add(2); list.add(3); list.add(3); list.add(3); // 验证是否被调用一次，等效于下面的times(1) verify(list).add(1); verify(list, times(1)).add(1); // 验证是否被调用2次 verify(list, times(2)).add(2); // 验证是否被调用3次 verify(list, times(3)).add(3); // 验证是否从未被调用过 verify(list, never()).add(4); // 验证至少调用一次 verify(list, atLeastOnce()).add(1); // 验证至少调用2次 verify(list, atLeast(2)).add(2); // 验证至多调用3次 verify(list, atMost(3)).add(3); &#125; 模拟方法抛出异常123456@Test(expected = RuntimeException.class) public void doThrow_when()&#123; List list = mock(List.class); doThrow(new RuntimeException()).when(list).add(1); list.add(1); &#125; 模拟执行顺序12345678910111213141516@Test public void verification_in_order()&#123; List list = mock(List.class); List list2 = mock(List.class); list.add(1); list2.add("hello"); list.add(2); list2.add("world"); //将需要排序的mock对象放入InOrder InOrder inOrder = inOrder(list,list2); //下面的代码不能颠倒顺序，验证执行顺序 inOrder.verify(list).add(1); inOrder.verify(list2).add("hello"); inOrder.verify(list).add(2); inOrder.verify(list2).add("world"); &#125; 确保模拟对象上无互动发生1234567891011@Test public void verify_interaction()&#123; List list = mock(List.class); List list2 = mock(List.class); List list3 = mock(List.class); list.add(1); verify(list).add(1); verify(list,never()).add(2); //验证零互动行为 verifyZeroInteractions(list2,list3); &#125; 找出冗余的互动(即未被验证到的)12345678910111213141516@Test(expected = NoInteractionsWanted.class) public void find_redundant_interaction()&#123; List list = mock(List.class); list.add(1); list.add(2); verify(list,times(2)).add(anyInt()); //检查是否有未被验证的互动行为，因为add(1)和add(2)都会被上面的anyInt()验证到，所以下面的代码会通过 verifyNoMoreInteractions(list); List list2 = mock(List.class); list2.add(1); list2.add(2); verify(list2).add(1); //检查是否有未被验证的互动行为，因为add(2)没有被验证，所以下面的代码会失败抛出异常 verifyNoMoreInteractions(list2); &#125; 使用注解的方式来快速模拟在上面的测试中我们在每个测试方法里都mock了一个List对象，为了避免重复的mock，是测试类更具有可读性，我们可以使用下面的（@Mock）注解方式来快速模拟对象： 12345678910111213@Mock private List mockList; //初始化mock public Program() &#123; MockitoAnnotations.initMocks(this); &#125; @Test public void shorthand()&#123; mockList.add(1); verify(mockList).add(1); &#125; 或者使用built-in runner：MockitoJUnitRunner 1234567891011@RunWith(MockitoJUnitRunner.class) public class MockitoExample2 &#123; @Mock private List mockList; @Test public void shorthand()&#123; mockList.add(1); verify(mockList).add(1); &#125; &#125; 更多的注解还有@Captor,@Spy,@InjectMocks 连续调用1234567891011121314@Test(expected = RuntimeException.class) public void consecutive_calls()&#123; //模拟连续调用返回期望值，如果分开，则只有最后一个有效 when(mockList.get(0)).thenReturn(0); when(mockList.get(0)).thenReturn(1); when(mockList.get(0)).thenReturn(2); when(mockList.get(1)).thenReturn(0).thenReturn(1).thenThrow(new RuntimeException()); assertEquals(2,mockList.get(0)); assertEquals(2,mockList.get(0)); assertEquals(0,mockList.get(1)); assertEquals(1,mockList.get(1)); //第三次或更多调用都会抛出异常 mockList.get(1); &#125; 使用回调生成期望值12345678910111213@Test public void answer_with_callback()&#123; //使用Answer来生成我们我们期望的返回 when(mockList.get(anyInt())).thenAnswer(new Answer&lt;Object&gt;() &#123; @Override public Object answer(InvocationOnMock invocation) throws Throwable &#123; Object[] args = invocation.getArguments(); return "hello world:"+args[0]; &#125; &#125;); assertEquals("hello world:0",mockList.get(0)); assertEquals("hello world:999",mockList.get(999)); &#125; 监控真实对象使用spy来监控真实的对象，需要注意的是此时我们需要谨慎的使用when-then语句，而改用do-when语句 12345678910111213141516171819202122@Test(expected = IndexOutOfBoundsException.class) public void spy_on_real_objects()&#123; List list = new LinkedList(); List spy = spy(list); //下面预设的spy.get(0)会报错，因为会调用真实对象的get(0)，所以会抛出越界异常 //when(spy.get(0)).thenReturn(3); //使用doReturn-when可以避免when-thenReturn调用真实对象api doReturn(999).when(spy).get(999); //预设size()期望值 when(spy.size()).thenReturn(100); //调用真实对象的api spy.add(1); spy.add(2); assertEquals(100,spy.size()); assertEquals(1,spy.get(0)); assertEquals(2,spy.get(1)); verify(spy).add(1); verify(spy).add(2); assertEquals(999,spy.get(999)); spy.get(2); &#125; 修改对未预设的调用返回默认期望值1234567891011121314@Test public void unstubbed_invocations()&#123; //mock对象使用Answer来对未预设的调用返回默认期望值 List mock = mock(List.class,new Answer() &#123; @Override public Object answer(InvocationOnMock invocation) throws Throwable &#123; return 999; &#125; &#125;); //下面的get(1)没有预设，通常情况下会返回NULL，但是使用了Answer改变了默认期望值 assertEquals(999, mock.get(1)); //下面的size()没有预设，通常情况下会返回0，但是使用了Answer改变了默认期望值 assertEquals(999,mock.size()); &#125; 捕获参数来进一步断言123456789101112131415161718192021222324252627282930313233343536373839404142434445@Test public void capturing_args()&#123; PersonDao personDao = mock(PersonDao.class); PersonService personService = new PersonService(personDao); ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class); personService.update(1,"jack"); verify(personDao).update(argument.capture()); assertEquals(1,argument.getValue().getId()); assertEquals("jack",argument.getValue().getName()); &#125; class Person&#123; private int id; private String name; Person(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; &#125; interface PersonDao&#123; public void update(Person person); &#125; class PersonService&#123; private PersonDao personDao; PersonService(PersonDao personDao) &#123; this.personDao = personDao; &#125; public void update(int id,String name)&#123; personDao.update(new Person(id,name)); &#125; &#125; 真实的部分mock1234567891011121314151617@Test public void real_partial_mock()&#123; //通过spy来调用真实的api List list = spy(new ArrayList()); assertEquals(0,list.size()); A a = mock(A.class); //通过thenCallRealMethod来调用真实的api when(a.doSomething(anyInt())).thenCallRealMethod(); assertEquals(999,a.doSomething(999)); &#125; class A&#123; public int doSomething(int i)&#123; return i; &#125; &#125; 重置mock12345678910@Test public void reset_mock()&#123; List list = mock(List.class); when(list.size()).thenReturn(10); list.add(1); assertEquals(10,list.size()); //重置mock，清除所有的互动和预设 reset(list); assertEquals(0,list.size()); &#125; 参考文章http://www.importnew.com/24741.html http://www.importnew.com/21153.html]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-log4j]]></title>
    <url>%2F2017%2F05%2F27%2Fjava-basic-log4j%2F</url>
    <content type="text"><![CDATA[前言项目在上线后，如果有日志记录，我们可以非常快速的跟踪问题产生的原因，可见log记录的重要性。 Log4j是什么 log4j是Apache的一个开源项目 log4j是一个功能强大的日志组件,提供方便的日志记录。 Log4j的引用如果是Maven项目，就使用以下引用 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; Gradle构建的项目就引用以下地址 1compile group: 'log4j', name: 'log4j', version: '1.2.17' Log4j的构成Log4j由三个重要组件构成：日志信息的优先级，日志信息的输出目的地，日志信息的输出格式。日志信息的优先级用来指定这条日志信息的重要程度，从高到低有：ERROR，WARN，INFO，DEBUG；日志信息的输出目的地指定了日志将打印到控制台还是文件中；日志的输出格式控制了日志信息的显示内容。 Log4j的配置我们在源代码根目录下，新建一个名为log4j.properties的文件。 配置根Logger 语法如下 1log4j.rootLogger = [ level ] , appenderName, appenderName, … 我们的自定义如下 1log4j.rootLogger = debug,stdout,C,D level是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。 配置日志信息输出目的地Appender 配置语法如下 1234log4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.option = valueN 我们自定的如下 1234log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n Appender除了上面配置的ConsoleAppender，我们还可以有以下几种配置 12345org.apache.log4j.ConsoleAppender（控制台）， org.apache.log4j.FileAppender（文件）， org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）， org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）， org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） Layout除了上面配置的org.apache.log4j.PatternLayout，我们也可以选择以下任意 1234org.apache.log4j.HTMLLayout（以HTML表格形式布局）， org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） 在上面最后一行配置表示打印格式，它类似与C语言的printf。%m 表示输出代码中指定的信息 配置[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n，会输出以下格式的日志 1[DEBUG] 2017-05-27 08:42:00,358 method:com.gold.p_demo.Program.main(Program.java:11) 各参数说明如下 1234567%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：com.gold.p_demo.Program.main(Program.java:11) log4j.properties完整配置如下 123456789101112131415161718192021222324### 设置###log4j.rootLogger = debug,stdout,C,D### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=C://logs/log.log ###log4j.appender.C = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.C.File = C://logs/log.loglog4j.appender.C.Append = truelog4j.appender.C.Threshold = DEBUG log4j.appender.C.layout = org.apache.log4j.PatternLayoutlog4j.appender.C.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=D://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File =D://logs/error.log log4j.appender.D.Append = truelog4j.appender.D.Threshold = ERROR log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n Log4j在程序中的使用获取记录器 1private static Logger logger =Logger.getLogger(Program.class); 读取配置文件 Log4j默认会从源代码根目录下找到名为log4j.properties的文件，当然我们也可以自己指定读取的目录，及方式 123BasicConfigurator.configure ()： 自动快速地使用缺省Log4j环境。 PropertyConfigurator.configure ( String configFilename) ：读取使用Java的特性文件编写的配置文件。 DOMConfigurator.configure ( String filename ) ：读取XML形式的配置文件。 插入记录信息 123456// 记录debug级别的信息 logger.debug("This is debug message."); // 记录info级别的信息 logger.info("This is info message."); // 记录error级别的信息 logger.error("This is error message."); 参考文章http://www.codeceo.com/article/log4j-usage.html]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SqlServer非规则列排序]]></title>
    <url>%2F2017%2F05%2F26%2Fdeal-sqlserver-data-sorting%2F</url>
    <content type="text"><![CDATA[前言今天有个客户发现一个问题，在系统导出的用户信息没有按照地址排序，然后花了几分钟改了下sql，就有了这篇文章。 发现问题这是系统中原来导出的数据 我们发现MetCardAddress这一列的值的规律。比如排序的话，会根据前两位进行，由于3比2大，导致3-1-1排在了29-5-9的后面。而实际用户希望的是3-1-1在29-5-9的前面 分析问题既然是数据列的值不统一导致的。那我们就把3-1-1改成03-1-1不就可以了。让用户把这些不规则的用户地址改成统一的，开玩笑，几万的数据，让用户改到手抽筋。因为懒，我又不想改动太多代码。我起身去了趟开水房，回来，就有灵感了。所以作为程序员要多喝水。 解决问题我在原来的sql语句中，把order by mc.Address改成了ORDER BY (case when mc.Address like &#39;_-%&#39; then &#39;0&#39;+mc.Address else mc.Address end)一切就解决了。]]></content>
      <categories>
        <category>Deal-Problem</category>
      </categories>
      <tags>
        <tag>SqlServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cheat-sheet-quartz]]></title>
    <url>%2F2017%2F05%2F25%2Fcheat-sheet-quartz%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[我喜欢什么样的文章]]></title>
    <url>%2F2017%2F05%2F25%2Frecord-what-article-i-love%2F</url>
    <content type="text"><![CDATA[前言这段时间，我一直在思考，有些文章我看后很有收获，有些文章看后就真的就像走了个过程。那么我看了特别有感觉的文章有什么特点，答案就在下文。 我看过的文章这是几篇，我看后感觉自己技术又提升了，有些知识点豁然开朗的感觉。 http://www.importnew.com/14479.html 我喜欢的文章 首先篇幅不要太长 一篇文章对于新概念，讲清楚一个足矣 整篇文章，围绕一个小案例来进行 文章中的每一段代码，都围绕小案例这个中心进行，没有多余的代码 对于知识点最好是图片+文字 未完待续]]></content>
  </entry>
  <entry>
    <title><![CDATA[deal-vs-can-not-hit-a-breakpoint]]></title>
    <url>%2F2017%2F05%2F25%2Fdeal-vs-can-not-hit-a-breakpoint%2F</url>
    <content type="text"><![CDATA[前言记录一次使用VS到时候，无法命中断点的处理经历。 发现问题当我命中断点的时候，出现了这个警告当前不会命中断点还未为文档加载符号 分析问题既然是调试的时候，出现的问题。首先怀疑了，测试文件。 解决问题删除了发布文件中的*.pdb文件，就OK了]]></content>
      <categories>
        <category>Deal-Problem</category>
      </categories>
      <tags>
        <tag>Dot-Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-注解]]></title>
    <url>%2F2017%2F05%2F25%2Fjava-basic-annotation%2F</url>
    <content type="text"><![CDATA[前言当我们在使用Spring,Hibernate,SpringMVC等框架的时候，都会用到很多注解。本文就揭开注解的面纱。 什么是注解(Annotation) Annotation就是Java提供了一种元程序中的元素关联任何信息和着任何元数据（metadata）的途径和方法。 Annotation是一个接口，程序可以通过反射来获取指定程序元素的Annotion对象，然后通过Annotion对象来获取注解里面的元数据。 Annotation是JDK5.0及以后版本引入的。 Annotation注解能够提供代码的相关信息，同时对于所注解的代码结构又没有直接影响 Annotation可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。 Annotation就像修饰符一样被使用，并应用于包、类 型、构造方法、方法、成员变量、参数、本地变量的声明中。这些信息被存储在Annotation的“name=value”结构对中 Annotation的成员在Annotation类型中以无参数的方法的形式被声明。其方法名和返回值定义了该成员的名字和类型。 一个Annotation可以将name=value对作为没有定义默认值的Annotation成员的值，当然也可以使用name=value对来覆盖其它成员默认值。 什么是元数据(metadata) 元数据从metadata一词译来，就是“关于数据的数据”的意思。 元数据可以用来创建文档，跟踪代码的依赖性，执行编译时格式检查，代替已有的配置文件。 元数据以标签的形式存在于Java代码中。 元数据描述的信息是类型安全的，即元数据内部的字段都是有明确类型的。 元数据需要编译器之外的工具额外的处理用来生成其它的程序部件。 元数据可以只存在于Java源代码级别，也可以存在于编译之后的Class文件内部。 自定义注解编写自定义注解与编写接口很相似，只要接口关键字前面加上@符号。 12345678910@Documented@Target(ElementType.METHOD)@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface MethodInfo &#123; String author()default "jack"; String date(); int revision() default 1; String comments();&#125; 注解方法不能有参数。 注解方法的返回类型局限于原始类型，字符串，枚举，注解，或以上类型构成的数组。 注解方法可以包含默认值。 注解可以包含与其绑定的元注解，元注解为注解提供信息，有四种元注解类型： @Documented：表示使用该注解的元素应被javadoc或类似工具文档化，它应用于类型声明，类型声明的注解会影响客户端对注解元素的使用。如果一个类型声明添加了Documented注解，那么它的注解会成为被注解元素的公共API的一部分。 @Target：表示支持注解的程序元素的种类，一些可能的值有TYPE, METHOD, CONSTRUCTOR, FIELD等等。如果Target元注解不存在，那么该注解就可以使用在任何程序元素之上。 @Inherited：表示一个注解类型会被自动继承，如果用户在类声明的时候查询注解类型，同时类声明中也没有这个类型的注解，那么注解类型会自动查询该类的父类，这个过程将会不停地重复，直到该类型的注解被找到为止，或是到达类结构的顶层（Object）。 @Retention：表示注解类型保留时间的长短，它接收RetentionPolicy参数，可能的值有SOURCE, CLASS, 以及RUNTIME。 Java内置注解Java提供3种内置注解。 @Override：当我们想要覆盖父类的一个方法时，需要使用该注解告知编译器我们正在覆盖一个方法。这样的话，当父类的方法被删除或修改了，编译器会提示错误信息。 @Deprecated– 当我们想要让编译器知道一个方法已经被弃用(deprecate)时，应该使用这个注解。Java推荐在javadoc中提供信息，告知用户为什么这个方法被弃用了，以及替代方法是什么。 @SuppressWarnings– 这个注解仅仅是告知编译器，忽略它们产生了特殊警告，比如：在java泛型中使用原始类型。它的保持性策略(retention policy)是SOURCE，在编译器中将被丢弃。 如何使用注解下面例子展示了如何使用内置注解，以及自定义的注解。 1234567891011121314151617181920212223242526public class AnnotationExample &#123; public static void main(String[] args) &#123; &#125; @Override @MethodInfo(author="rose",comments="Main method",date="20170101",revision=1) public String toString() &#123; return "Overidden toString method"; &#125; @Deprecated @MethodInfo(comments="deprecated method",date="20160101",revision=2) public static void oldMethod()&#123; System.out.println("old method, don't use it."); &#125; @SuppressWarnings(&#123;"unchecked","deprecation"&#125;) @MethodInfo(author="frank",comments="Main method",date="20170102") public static void genericsTest()&#123; List list = new ArrayList&lt;&gt;(); list.add("abc"); oldMethod(); &#125;&#125; Java注解解析我们将使用Java反射机制从一个类中解析注解，请记住，注解保持性策略应该是RUNTIME，否则它的信息在运行期无效，我们也不能从中获取任何数据。 123456789101112131415161718192021public class AnnotationParsing &#123; public static void main(String[] args) throws Exception &#123; ClassLoader classLoader = AnnotationParsing.class.getClassLoader(); Method[] methods =classLoader.loadClass("com.gold.o_demo.AnnotationExample").getMethods(); for(Method method:methods)&#123; if(method.isAnnotationPresent(MethodInfo.class))&#123; for(Annotation anno:method.getDeclaredAnnotations())&#123; //System.out.println(method+":"+anno); &#125; MethodInfo methodInfo =method.getAnnotation(MethodInfo.class); //System.out.println(methodInfo); if(methodInfo.revision()==1)&#123; System.out.println(method); &#125; &#125; &#125; &#125;&#125; 参考文章http://www.cnblogs.com/peida/archive/2013/04/23/3036035.html http://www.importnew.com/14479.html]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cheat-sheet-think-different]]></title>
    <url>%2F2017%2F05%2F24%2Fcheat-sheet-think-different%2F</url>
    <content type="text"><![CDATA[前言本文主要记录自己平时的一些瞬间灵感。 Think Different这个技术主要解决了什么问题？]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础-字符串]]></title>
    <url>%2F2017%2F05%2F24%2Fjava-basic-string%2F</url>
    <content type="text"><![CDATA[前言我们为什么需要String，String能为我们做什么，有哪些好用的String工具类。 String是什么以下是JDK中的String的定义，在rt.jar包下。 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String类型实现了CharSequence接口，我们再看下这个接口 123456public interface CharSequence &#123; int length(); char charAt(int index); CharSequence subSequence(int start, int end); public String toString();&#125; CharSequence还有两个子类StringBuilder和StringBuffer CharSequence解决了解决了什么问题 因为String对象不可变的，我们在拼接字符串的时候，常用的是StringBuilder和StringBuffer。如果我们的方法传参只能是String类型，那么我们每次调用方法，都要调用toString()转换成String才能用。而这个转换是要花费时间的，所有就出现了CharSequence类型。 String能为我们做什么我们首先看下String类可以为我们做什么 String工具类在commons-lang3.jar下有个字符串工具类]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-basic-regular-expression]]></title>
    <url>%2F2017%2F05%2F23%2Fjava-basic-regular-expression%2F</url>
    <content type="text"><![CDATA[前言本文主要记录正则表达式的使用 匹配验证-验证Email是否正确1234567891011//验证的字符串 String inputString = "JackLoveRose@126.com"; //验证规则 String reg="[a-zA-Z_]&#123;1,&#125;[0-9]&#123;0,&#125;@(([a-zA-z0-9]-*)&#123;1,&#125;\\.)&#123;1,3&#125;[a-zA-z\\-]&#123;1,&#125;"; //编译正则表达式 Pattern pattern = Pattern.compile(reg); //匹配正则 Matcher matcher = pattern.matcher(inputString); //返回匹配结果 boolean result = matcher.matches(); System.out.println(result); Pattern.compile()的第二个参数可以添加一些匹配约束 UNIX_LINES：使用Unix模式 Pattern.CASE_INSENSITIVE：不区分大小写 COMMENTS：运行空格和注释 MULTILINE：多行模式 LITERAL： DOTALL UNICODE_CASE CANON_EQ UNICODE_CHARACTER_CLASS 在字符串中查找字符12345678910111213//验证的字符串 String inputString = "JackLoveRose@126.com"; //验证规则 String reg="Lov."; //编译正则表达式 Pattern pattern = Pattern.compile(reg); //匹配正则 Matcher matcher = pattern.matcher(inputString); //返回匹配结果 boolean result = matcher.find(); if(result)&#123; System.out.println(matcher.group());//Love &#125; 参考文章http://www.cnblogs.com/lzq198754/p/5780340.html http://blog.csdn.net/allwefantasy/article/details/3136570/]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-反射]]></title>
    <url>%2F2017%2F05%2F23%2Fjava-basic-reflect%2F</url>
    <content type="text"><![CDATA[前言好多语言都有反射的功能，那什么是反射，为什么要有反射 反射机制是什么反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 反射机制能做什么在框架中很常用，不需要写死代码 反射机制的相关API获取Class对象123Class&lt;?&gt; clazz1 = Class.forName("com.gold.m_demo.Employee");Class&lt;?&gt; clazz2 = new Employee().getClass();Class&lt;?&gt; clazz3 = Employee.class; 获取对象的父类及接口123Class&lt;?&gt; clazz = Class.forName("com.gold.m_demo.Employee");Class&lt;?&gt; parentClass =clazz.getSuperclass();Class&lt;?&gt;[] interfaces = clazz.getInterfaces(); 获取类的构造方法12345678910111213Class&lt;?&gt; clazz = Class.forName("com.gold.m_demo.Employee");//获取所有public的构造函数Constructor&lt;?&gt;[] constructors = clazz.getConstructors();//根据参数类型获取指定public的构造函数Constructor&lt;?&gt; constructor2 = clazz.getConstructor(String.class,Integer.class);//获取所有的构造函数Constructor&lt;?&gt;[] constructors3 =clazz.getDeclaredConstructors();//根据参数类型获取指定构造函数Constructor&lt;?&gt; constructor4 = clazz.getDeclaredConstructor(String.class); 动态创建对象1234567Class&lt;?&gt; clazz = Class.forName("com.gold.m_demo.Employee");//方式一：必须提供无参构造函数Employee employee1 = (Employee)clazz.newInstance();//方式二：根据参数来创建指定数据库Constructor&lt;?&gt; constructor2 = clazz.getConstructor(String.class,Integer.class);Employee employee2 = (Employee)constructor2.newInstance("jack",18); 获取类的属性123456//根据变量名，返回一个具体的具有public属性的成员变量Field field = clazz.getField("createTime"); //返回具有public属性的成员变量的数组Field[] fields = clazz.getFields(); //返回所有成员变量组成的数组（不分public和非public属性） Field[] fields2 = clazz.getDeclaredFields(); Field的其他信息 123456789101112Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; //获取权限修饰符 int mo = field.getModifiers(); System.out.print(Modifier.toString(mo)); //获取属性类型 System.out.print("\t"+field.getType()); //获取属性名 System.out.print("\t"+field.getName()); System.out.println(); &#125; 获取类的方法1234567Class&lt;?&gt; clazz = Class.forName("com.gold.m_demo.Employee"); //根据方法名和参数，返回一个具体的具有public属性的方法 Method method = clazz.getMethod("setName", String.class); //返回所有(包括父类)具有public属性的方法数组 Method[] methods=clazz.getMethods(); //返回该类中的所有的方法数组（不分public和非public属性） Method[] methods2=clazz.getDeclaredMethods(); Method的其他方法 123456789Method[] methods=clazz.getMethods(); for (Method m : methods) &#123; if(m.getName().equals("wait"))&#123; System.out.println(m); Class&lt;?&gt;[] parasTypes = m.getParameterTypes(); Class&lt;?&gt; returnType = m.getReturnType(); Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes(); &#125; &#125; 调用类的方法1234567Class&lt;?&gt; clazz = Class.forName("com.gold.m_demo.Employee"); //获取方法，然后在调用方法 Method method = clazz.getMethod("setName", String.class); method.invoke(clazz.newInstance(),"rose"); Method method2 = clazz.getMethod("hello", String.class,Integer.class); method2.invoke(clazz.newInstance(), "jack",18); 操作类的属性1234567891011Class&lt;?&gt; clazz = Class.forName("com.gold.m_demo.Employee"); Object obj =clazz.newInstance(); //获取属性，赋值 Field field = clazz.getDeclaredField("name"); field.setAccessible(true); field.set(obj, "杰克"); //取值 System.out.println(field.get(obj)); 反射机制的应用实例在泛型Integer的ArrayList中存放一个String类型的对象1234ArrayList&lt;Integer&gt;list=new ArrayList&lt;&gt;(); Method method=list.getClass().getMethod("add", Object.class);method.invoke(list, "abc"); System.out.println(list.get(0)); 通过反射取得并修改数组的信息1234567int[] intArr = &#123; 1, 2, 3, 4, 5 &#125;; Class&lt;?&gt; clazz = intArr.getClass().getComponentType(); System.out.println("数组类型：" + clazz.getName()); System.out.println("数组长度：" + Array.getLength(intArr)); System.out.println("数组第一个元素：" + Array.getInt(intArr, 0)); Array.set(intArr, 0, 100); System.out.println("修改后第一个元素：" + Array.getInt(intArr, 0)); 通过反射修改数组的大小1234567int[] intArr = &#123; 1, 2, 3, 4, 5 &#125;; Class&lt;?&gt; componetType=intArr.getClass().getComponentType();Object obj = Array.newInstance(componetType, 10); System.arraycopy(intArr, 0, obj, 0, intArr.length); int[] newIntArr =(int[])obj; System.out.println(Arrays.toString(newIntArr)); 参考文章http://www.cnblogs.com/lzq198754/p/5780331.html http://www.journaldev.com/1789/java-reflection-example-tutorial]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AweSome]]></title>
    <url>%2F2017%2F05%2F20%2Fcheat-sheet-awesome%2F</url>
    <content type="text"><![CDATA[前言就如标题写的，这是一个awesome文章。用来收集各种有趣东西。 GitHubAwesom的鼻祖：https://github.com/sindresorhus/awesome Blog刘大推荐的学英语的网站：https://www.joelonsoftware.com/ 吴晓波新浪博客：http://blog.sina.com.cn/wuxiaobo2009]]></content>
      <categories>
        <category>Cheat-Sheet</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[deal-mysql-connect-faild]]></title>
    <url>%2F2017%2F05%2F17%2Fdeal-mysql-connect-faild%2F</url>
    <content type="text"><![CDATA[前言今天在做SqlServer数据库转MySql数据库时，遇到的一点小麻烦的处理。 发现问题因为Navicat提供了一个不同类型数据库的转换，因为我本地也安装了MySql和SqlServer。在我本地环境下做SqlServer转MySql的时候，一切正常。但是，当我本地的SqlServer，局域网内服务器上的MySql的时候，测试连接的时候失败了，报了以下错误。 下图是我选择的连接驱动 分析问题排除我Navicat的问题 我卸载了Navicat，用我同事的版本重新安装，还是失败 排除电脑环境问题 我使用同事的电脑，做相同的操作，竟然转换成功了 那问题可以确定，就是我电脑环境的问题。那我就一点一点的排查，在转换数据库时，需要准备几个参数：服务器名称,登录服务器信息，服务器上的数据库。直觉告诉我，这几个参数唯一可能有问题，只能是服务器名称。但是服务器名称上不填我本机的Ip，我真不知道还能填什么。然后就开始了百度，谷歌过程。 解决问题服务器名称要填我本机的计算机名。 打开我的电脑，右击属性，拷贝计算机名 将计算机名，黏贴到相应位置 然后点击测试连接，就成功了]]></content>
      <categories>
        <category>Deal-Problem</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[record-healthy-life]]></title>
    <url>%2F2017%2F05%2F15%2Frecord-healthy-life%2F</url>
    <content type="text"><![CDATA[前言本文主要是记录自己的健康生活 20170515晚上8点出门，出去跑步了36分钟，有图有真相 图一 图二 图三 20170516晚上做了20个俯卧撑，步行4000步 20170517不行10000步，没图说个J8 20170518 20170520 20170521 20170522 20170523 20170524 20170525]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机基础-原码、反码、补码]]></title>
    <url>%2F2017%2F05%2F15%2Fcomputer-basic-code%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍什么是原码、反码和补码，以及计算机为什么要用补码 机器数和真值在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念. 机器数 一个数在计算机中的二进制表上形式，叫做这个数的机器数； 机器数是带符号的，最高位存放符号(0正，1负)； 00000011和10000011就是机器数； 真值 将带符号位的机器数对应的真正数值称为机器数的真值。 00000011的真值是+1； 10000011的真值是-1； 原码, 反码, 补码的基础概念和计算方法对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式. ###原码 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值.比如如果是 8 位二进制: 12[+1]原 = 0000 0001[-1]原 = 1000 0001 因为第一位是符号位, 所以原码表示的8位二进制数的取值范围就是 1[1111 1111 , 0111 1111] 即 1[-127 , 127] 原码是人脑最容易理解和计算的表示方式. 反码正数的反码是其本身。负数的反码是在其原码的基础上, 符号位不变，其余各个位取反. 12[+1] = [00000001]原 = [00000001]反[-1] = [10000001]原 = [11111110]反 可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算. 补码正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) 12[+1] = [00000001]原 = [00000001]反 = [00000001]补[-1] = [10000001]原 = [11111110]反 = [11111111]补 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 为何要使用原码, 反码和补码现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同 1[+1] = [00000001]原 = [00000001]反 = [00000001]补 所以不需要过多解释. 但是对于负数: 1[-1] = [10000001]原 = [11111110]反 = [11111111]补 可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢? 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:计算十进制的表达式: 1-1=0 11 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数. 为了解决原码做减法的问题, 出现了反码: 计算十进制的表达式: 1-1=0 11 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0. 于是补码的出现, 解决了0的符号以及两个编码的问题 11-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128: 1(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的) 因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值. 参考文章http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[java-basic-byte]]></title>
    <url>%2F2017%2F05%2F12%2Fjava-basic-byte%2F</url>
    <content type="text"><![CDATA[前言因为最近在看java字节码，设计到大量的byte的操作，此篇就记录一下 脚下留心 byte的范围 byte的占一个字节，即8位，最高位表示符号位 byte的最大值为01111111，转换为十进制为127 byte的最小值为10000000，转换为十进制为-128 案例 以下代码输出为202，但是为什么呢 12int b1 = -54 &amp; 0xff; System.out.println(b1); -54转化为二进制为10110110，因为计算机的运算是根据补码来进行运算的。10110110的反码是11001001，反码加1就是补码11001010。然后用11001010与11111111做与运算，即将符号位当做数值位，得到11001010，即十进制202 参考文章http://blog.csdn.net/u012582402/article/details/51785528http://blog.163.com/yurong_1987@126/blog/static/47517863200911314245752/http://blog.csdn.net/leonwang_fly/article/details/47422235http://www.360doc.com/content/10/0813/21/495229_45854066.shtml]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础-类加载机制]]></title>
    <url>%2F2017%2F05%2F12%2Fjava-basic-classloader%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍下Java的类加载机制 类加载器 什么是ClassLoader ClassLoader是JVM的一个重要组成部分。Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能。 什么是JVM的类加载机制 ClassLoader把class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被JVM直接使用的Java类型，这个过程就叫做JVM的类加载机制。 类加载机制的工作机制 类加载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类加载器把一个类装入JVM中，要经过以下步骤： 转载：查找和导入Class文件 链接：把类的二进制数据合并到JRE中 校验：检查载入Class文件数据的正确性 准备：给类的静态变量分配存储空间 解析：将符号引用转成直接引用 初始化：对类的静态变量，静态代码块执行初始化操作 Java程序能不能进行动态扩展 Java程序可以动态扩展是由运行期动态加载和动态链接实现的；比如：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现(多态)，解析过程有时候还可以在初始化之后执行；比如：动态绑定(多态)； 工作机制类初始化只有以下四种情况会触发初始化，也称为对一个类进行主动引用，除此以外，所有其他方式都不会触发初始化，称为被动引用 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 被动使用类字段Demo1 通过子类引用父类的静态字段，不会触发子类的初始化 123456789101112131415161718class SuperClass &#123; static &#123; System.out.println("SuperClass init"); &#125; public static int value = 123;&#125;class SubClass extends SuperClass &#123; static &#123; System.out.println("SubClass init"); &#125;&#125;public class NotInitialization &#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125;&#125; 装载在装载阶段，虚拟机需要完成以下3件事情 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。 虚拟机规范中并没有准确说明二进制字节流应该从哪里获取以及怎样获取,这里可以通过定义自己的类加载器去控制字节流的获取方式。 验证虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统奔溃。 准备准备阶段是正式为类变量分配并设置类变量初始值的阶段，这些内存都将在方法区中进行分配,需要说明的是： 这时候进行内存分配的仅包括类变量(被static修饰的变量),而不包括实例变量,实例变量将会在对象实例化时随着对象一起分配在Java堆中;这里所说的初始值“通常情况”是数据类型的零值，假如: public static int value = 123; value在准备阶段过后的初始值为0而不是123,而把value赋值的putstatic指令将在初始化阶段才会被执行 类加载器与双亲委派模型类加载器 启动类加载器(Bootstrap ClassLoader)：将存放于\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用 扩展类加载器(Extension ClassLoader)：将\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。 应用类加载器(Application ClassLoader)：负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用。 工作过程 如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 双亲委派的好处 java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。 实现双亲委托的主要代码 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 反射Reflection机制允许程序在正在执行的过程中，利用Reflection APIs取得任何已知名称的类的内部信息，包括：package、 type parameters、 superclass、 implemented interfaces、 inner classes、 outer classes、 fields、 constructors、 methods、 modifiers等，并可以在执行的过程中，动态生成instances、变更fields内容或唤起methods。 获取构造方法Class类提供了四个public方法，用于获取某个类的构造方法。 Constructor getConstructor(Class[] params)：根据构造函数的参数，返回一个具体的具有public属性的构造函数 Constructor getConstructors()：返回所有具有public属性的构造函数数组 Constructor getDeclaredConstructor(Class[] params)：根据构造函数的参数，返回一个具体的构造函数（不分public和非public属性） Constructor getDeclaredConstructors()：返回该类中所有的构造函数数组（不分public和非public属性） 获取类的成员方法与获取构造方法的方式相同，存在四种获取成员方法的方式。 Method getMethod(String name, Class[] params)：根据方法名和参数，返回一个具体的具有public属性的方法 Method[] getMethods()：返回所有具有public属性的方法数组 Method getDeclaredMethod(String name, Class[] params)：根据方法名和参数，返回一个具体的方法（不分public和非public属性） Method[] getDeclaredMethods()：返回该类中的所有的方法数组（不分public和非public属性） 获取类的成员变量（成员属性）存在四种获取成员属性的方法 Field getField(String name)：根据变量名，返回一个具体的具有public属性的成员变量 Field[] getFields()：返回具有public属性的成员变量的数组 Field getDeclaredField(String name)：根据变量名，返回一个成员变量（不分public和非public属性） Field[] getDelcaredFields()：返回所有成员变量组成的数组（不分public和非public属性） 参考文章http://www.cnblogs.com/ITtangtang/p/3978102.html]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git冲突导致文件丢失]]></title>
    <url>%2F2017%2F05%2F06%2Fdeal-git-file-lose%2F</url>
    <content type="text"><![CDATA[前言本文主要记录自己一次Git文件丢失处理 发现问题我个人笔记本上做了git push，而在公司笔记本上未做git pull的情况下，直接做了文件的修改，然后做git commit，再做git push的时候，出现了错误。我就用git pull，结果代码冲突了，并乱码了 分析问题既然是代码冲突，那我找到之前的代码，然后手动拷贝一份，再在最新代码上修改就可以了 解决问题 使用git log找到昨天的日志，然后执行git checkout sha-1值，我把我需要的代码拷贝一份 使用git log -g来找到我需要恢复的信息对应的commited，依旧执行git checkout sha-1值，把修改的代码恢复一下 现在代码不在master上，还push不了。我执行了git checkout master，然后在git push就解决了]]></content>
  </entry>
  <entry>
    <title><![CDATA[gradle-custom-property]]></title>
    <url>%2F2017%2F05%2F06%2Fgradle-custom-property%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍如何自定义Property 脚下留心Property的使用设置和读取Project的Property是使用Gradle的一个很重要的方面。很多Plugin都会向Project中加入额外的Property，在使用这些Plugin时，我们需要对这些Property进行赋值 Gradle在默认情况下已经为Project定义了很多Property，常用的有以下 project：Project本身 name：Project的名字 path：Project的绝对路径 description：Project的描述信息 buildDir：Project构建结果存放目录 version：Project的版本号 使用方法：先设置在打印 1234567version = 'this is the project version'description = 'this is the project description'task showProjectProperties &lt;&lt; &#123; println version println project.description&#125; 在打印description时，我们使用了project.description，而不是直接使用description。原因是Project和Task都拥有description属性，而定义Task的闭包将delegate设置成了当前的Task，因此如果直接使用description，此时打印的是showProjectProperties的description，而不是Project的，所以我们需要显式地指明project 在build.gradle文件中定义Property在build.gradle文件中向Project添加额外的Property时，我们不能直接定义，可以通过以下两种方式定义。 方式一：通过ext来定义 1ext.property1 = 'this is property1' 方式二：通过闭包的方式 123ext &#123; property2 = 'this is property2'&#125; Output 1234task showProperties &lt;&lt; &#123; println property1 println property2&#125; 实际上，任何实现了ExtensionAware接口的Gradle对象都可以通过这种方式来添加额外的Property，比如Task也实现了该接口 通过命令行参数定义PropertyGradle还提供了-P 命令行参数来设置Property build.gradle 123task showCommandLineProperties &lt;&lt; &#123; println property3&#125; Output 执行gradle -P property3=&quot;this is property3&quot; showCommandLineProperties，可以在控制台看到输出 通过JVM系统参数定义Property在Java中，通过-D参数定义JVM的系统参数，然后在代码中可以通过System.getProperty()来获取。在Gradle中，我们也可以通过-D的方式向Project传入Property，只是此时我们需要遵循一个约定：每一个通过-D方式声明的Property都需要以org.gradle.project为前缀 build.gradle 123task showCommandLineProperties &lt;&lt; &#123; println property3&#125; Output 执行gradle -D org.gradle.project.property3=&quot;this is another property3&quot; showCommandLineProperties，在控制台可看到输出 通过环境变量设置Property我们可以通过设置环境变量的方式设置Project的Property。我们也要遵循一个约定：在定义环境变量时，每个Property都需要以ORG_GRADLE_PROJECT_为前缀 build.gradle 123task showCommandLineProperties &lt;&lt; &#123; println property3&#125; Output Linux下设置环境变量 1export ORG_GRADLE_PROJECT_property3="this is yet another property3" Windows下设置环境变量 1set ORG_GRADLE_PROJECT_property3="this is yet another property3" Output 执行gradle showCommandLineProperties，可看到输出]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Gradle系列-增量式构建]]></title>
    <url>%2F2017%2F05%2F06%2Fgradle-incremental-build%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍使用Gradle进行增量式构建 脚下留心什么是增量式构建 如果把Gradle的Task看作一个黑盒子，那么我们可以抽象出输入和输出两个概念，一个Task对输入进行操作，然后产生输出。比如，在使用java插件编译源代码时，输入即Java源文件，输出则为class文件。如果多次执行一个Task时的输入和输出是一样的，那么我们便可以认为这样的Task是没有必要重复执行的，因为反复执行相同的Task是冗余的。 为了解决这样的问题，Gradle引入了增量式构建的概念。在增量式构建中，我们为每个Task定义输入和输出，在执行一个Task时，如果它的输入和输出与前一次执行时没有发生变化，那么Gradle便会任务该Task是最新的(UP-TO-DATE)，因此Gradle将不会重复执行。一个Task的inputs和outputs可以是一个或多个文件，可以是文件夹，还可以是Project的某个Property，甚至可以是某个闭包所定义的条件 每个Task都拥有inputs和outputs属性，他们的类型分别为TaskInputs和TaskOuputs。下面Task的功能是从sourceDir目录中读取所有的文件，然后将每个文件的内容合并到destination.txt中 没有增量式 项目结构 1234--build.gradle--sourceDir----source1.xml----source2.xml source1.xml 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;person&gt; &lt;name&gt;Davenkin1&lt;/name&gt; &lt;gender&gt;Female&lt;/gender&gt;&lt;/person&gt; source2.xml 12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;person&gt; &lt;name&gt;Davenkin2&lt;/name&gt; &lt;gender&gt;Male&lt;/gender&gt;&lt;/person&gt; build.gradle 1234567891011task combineFileContentNonIncremental &#123; def sources = fileTree('sourceDir') def destination = file('destination.txt') doLast &#123; destination.withPrintWriter &#123; writer -&gt; sources.each &#123; source-&gt; writer.println source.text &#125; &#125; &#125;&#125; Output 我们每次执行gradle combineFileContentNonIncremental，Task都会被执行，从destionation.txt的创建时间可以看到 增量式构建 项目结构同上，唯一不同的是Task中多了两行代码 123456789101112131415task combineFileContentIncremental &#123; def sources = fileTree('sourceDir') def destination = file('destination2.txt') inputs.dir sources outputs.file destination doLast &#123; destination.withPrintWriter &#123; writer -&gt; sources.each &#123; source -&gt; writer.println source.text &#125; &#125; &#125;&#125; Output 我们发现，当我们重复执行Task时，会输出combineFileContentIncremental UP-TO-DATE，表示该Task是最新的，Gradle不会执行 扩展 我们还可以使用upToDateWhen()方法决定一个Task的outputs是否为最新的，该方法接受一个闭包作为检查条件]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cheat-sheet-database-connection]]></title>
    <url>%2F2017%2F05%2F03%2Fcheat-sheet-database-connection%2F</url>
    <content type="text"><![CDATA[1234DBDriver=com.microsoft.sqlserver.jdbc.SQLServerDriverUrl=jdbc\:sqlserver\://127.0.0.1:2008;databaseName\=GMS_GZLUid=saPwd=123]]></content>
  </entry>
  <entry>
    <title><![CDATA[tutorial-linq]]></title>
    <url>%2F2017%2F05%2F03%2Ftutorial-linq%2F</url>
    <content type="text"><![CDATA[前言今天在给一个ASP.NET项目加需求时，有个Linq的语法死活都写不对。太久没写C#代码，都快忘本了，我是.Net出家的。这篇作为.Net文章的开头吧，后面有时间再补充。 脚下留心not in 1234var list = (from p in pi.List where !(new int[]&#123;26&#125;).Contains(p.FeeItem.ID) select new &#123;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Groovy学习笔记]]></title>
    <url>%2F2017%2F05%2F02%2Ftutorial-groovy%2F</url>
    <content type="text"><![CDATA[前言因为最近在学习Gradle，涉及到一些Groovy语法，然后就花了一些时间入了门 是什么Groovy是Java平台上设计的面向对象编程语言。这门动态语言拥有类似Python、Ruby和Smalltalk中的一些特性，可以作为Java平台的脚本语言使用。Groovy的语法与Java非常相似，以至于多数的Java代码也是正确的Groovy代码。Groovy代码动态地被编译器转换成Java字节码。由于其运行在JVM上的特性，Groovy可以使用其他Java语言编写的库。 开发环境官方地址：http://www.groovy-lang.org/ Eclipse插件地址：https://github.com/groovy/groovy-eclipse/wiki 开发过程：用Eclipse新建一个Groovy项目；新建一个Groovy Class；右击run as groovy script 入门例子 Main.java 12345class Main &#123; static void main(def args)&#123; println("Hello Groovy") &#125;&#125; Analyze Groovy是动态语言，def表示变量的声明类型，再赋值时编译器自动识别类型 Groovy中默认的修饰符就是public Groovy中语句后面是不需要加分号结束的 字符串连接方式一： 123def s1 = "hello "+ "Groovy" println(s1) 方式二(回车和tab会被保留下来)： 123def s2 = """Hello Groovy""" println(s2) 循环方式一： 123for(def i = 0;i&lt; 5 ;i++)&#123; println("Hello Groovy")&#125; 方式二: 输出0,1,2,3,4,5 123for(i in 0..5)&#123; println(i) &#125; 分析： 0..5表示包含整数0,1,2,3,4,50..&lt;5表示包含整数0,1,2,3,4 方式三: Gstring字符串类型，用”号括住 123for(i in 0..5)&#123; println "This is $&#123;i&#125;" &#125; 默认值123456789static def repeat(val,count=3)&#123; for(i in 0..&lt;count)&#123; println "This is $&#123;i&#125;:$&#123;val&#125;" &#125; &#125; static void main(def arg)&#123; repeat("Hello Groovy") &#125; 集合List集合中加元素 1234567def collect=["a","b","c"] collect.add(1) collect&lt;&lt;"d" collect[collect.size()]="f" collect=collect+"g"//在集合中添加元素g collect=collect-"f"//在集合中删除元素f collect=collect-collect[0..1]//删除集合中前2个元素 集合中元素的访问 123println(collect) println(collect[0]) println(collect[-1])//倒数第一个元素f Map123456789def map=["name":"jack","age":18] map=map+["sex":"male"] map.put("hobby","chess") map.hair="black" println(map) println(map["name"]) 集合的遍历方式一 key,value两个参数用于接受每个元素的键，值 闭包也是对象，可以作为一个参数传递给each()方法 12345def map=["name":"jack","age":18,"sex":"male"] map.each(&#123; key,value-&gt;println "$key:$value" &#125;) 输出 123name:jackage:18sex:male 方式二 it是一个关键字，代表map集合的每一个元素 123map.each&#123; println it &#125; 输出 123name=jackage=18sex=male 方式三 123map.each(&#123; println it.getKey()+"--&gt;"+it.getValue()&#125;) 输出 123name--&gt;jackage--&gt;18sex--&gt;male 闭包定义和执行闭包 Main.java 123456789def one=&#123; num1,num2-&gt;println "param is : $num1 &amp; &#125; one(2,3) //输出param is 2 &amp; 3 one 2,3 //省略()的等效写法 one.call(2,3)//使用call()方法 one.call 2,3 //省略()等效写法 Analyze 闭包自身的定义写法。在参数与具体代码执行端间的分隔符是-&gt;，老版本的是| 使用call方法，或简便写法 由于groovy可以省略()，而引发的众多等效写法 单 闭包作为参数返回 Main.java 1234567891011static def makeClosure(name)&#123; return&#123; println "Hello $&#123;name&#125;" &#125; &#125; static void main(def arg)&#123; makeClosure("World")() //Hello World &#125; Analyze makeClosure()方法返回的是一个闭包对象，而闭包可以理解为一个匿名函数。当调用makeClosure(&quot;World&quot;)()时，其实就是执行闭包内的代码 闭包作为参数传递 Main.groovy 1234567891011static def run(a)&#123; a.call() &#125; static void main(def arg)&#123; def one=&#123;println "Hello World"&#125; run(one) &#125; Analyze Groovy执行方法的方式有两种：方式一：a.call()；方式二：a() 闭包使用外部变量使用闭包实现单方法接口 IFly.groovy 123interface IFly &#123; def one()&#125; Main.groovy 12345static void main(def arg)&#123; def fly=&#123;println "fly fly"&#125; as IFly fly.one() &#125; Analyze 使用关键字as 使用闭包实现多方法接口 IFly.groovy 1234interface IFly &#123; def one() def two()&#125; Main.groovy 12345678910static void main(def arg)&#123; def fly=[ one:&#123;println "one"&#125;, two:&#123;println "two"&#125; ] as IFly fly.one() fly.two() &#125; Analyze 使用关键字as 使用Map。key为方法名，value为闭包 闭包是用{符号括起来的代码块，它可以被单独运行或调用，也可以被命名。类似匿名类或内联函数的概念 闭包中最常见的应用是对集合进行迭代 类不需要public修饰符：groovy的默认修饰符就是public不需要类型说明：groovy不关心变量和方法参数的具体类型不需要getter/setter方法：底层默认实现了这些方法不需要构造函数：groovy提供了两个构造函数：不带参数的默认构造函数，只带一个map参数的构造函数。不需要return：看下面例子不需要()号：方法调用可以省略() Person.groovy 12345678class Person&#123; def name def age public String toString() &#123; "$name:$age" &#125;&#125; Main.groovy 1234567891011class Main &#123; static void main(def arg)&#123; def map=["name":"jack","age":18] def person = new Person(map); def person2 =new Person("name":"jack","age":18) println(person) println person2 &#125;&#125; Output 12jack:18jack:18 ?运算符 Main.java 12345def map=["name":"jack","age":18] println(map) map=null println map?.size() Output 1null Analyze ?在这里是一个条件运算符，如果?前面的对象非null，执行后面的方法，否则什么也不做，即println map 可变参数1234567891011121314class Main &#123; static int sum(int...var)&#123; def total=0 for(i in var)&#123; total += i &#125; return total &#125; static void main(def arg)&#123; println sum(1,2,3) &#125;&#125; 枚举 Day.java 1234public enum Day &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY, SATURDAY,SUNDAY&#125; Main.groovy 1234567891011121314static void main(def arg)&#123; def today = Day.WEDNESDAY switch(today)&#123; case [Day.SATURDAY, Day.SUNDAY]: println "Weekends are cool" break case Day.MONDAY..Day.FRIDAY: println "Boring work day" break default: println "Are you sure this is a valid day?" &#125; &#125; 同Java，枚举也可以带参数 三目运算符12def name = null println name!=null?name:"UnKnown" 因为null在groovy中可以转换为布尔值false，可以简化为 1println name?name:"UnKnown" 反射1234567891011121314151617static void main(def arg)&#123; def msg ="Hello" println msg.metaClass String.metaClass.up=&#123;delegate.toUpperCase()&#125; println msg.up() msg.metaClass.methods.each&#123;println "method:"+it.name&#125; msg.metaClass.properties.each&#123;println "property:"+it.name&#125; if(msg.metaClass.respondsTo(msg,"up"))&#123; println msg.up() &#125; println msg.metaClass.hasProperty(msg,"bytes") &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[gradle-grammar]]></title>
    <url>%2F2017%2F05%2F01%2Fgradle-grammar%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍Gradle的一些语法 脚下留心 build.gradle 以下3个Task完成的功能是一样的，即先设置Task的description属性，再将其输出到命令行。 方式一 定义一个Task的同时便设置description 1234task shwoDescription1 &lt;&lt; &#123; description = "this is task showDescription" println description&#125; 方式二 定义的Task本身是Project的一个Property，给这个Property添加新的Property 1234task shwoDescription2 &lt;&lt; &#123; println description&#125;showDescription2.description = "this is task showDescription2" 方式三 定义一个Task，在与它同名的方法中设置description 1234567task shwoDescription3 &lt;&lt; &#123; println description&#125;shwoDescription3 &#123; description = "this is task shwoDescrtiption3"&#125;]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gradle-create-task]]></title>
    <url>%2F2017%2F05%2F01%2Fgradle-create-task%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍创建Task的几种方式。 脚下留心Gradle的Project从本质上说只是含有多个Task的容器。 调用Project的task()方法创建Task build.gradle 123task hello1 &lt;&lt; &#123; println "hello1"&#125; Analyze 这里的&lt;&lt;表示追加的意思，即向hello1中加入执行过程。我们也可以使用doLast达到同样的效果 12345task hello2 &#123; doLast &#123; println "hello2" &#125;&#125; 如果我们需要向Task的最前面加入执行过程，可以使用doFirst 12345task hello3 &#123; doFirst &#123; println "hello3" &#125;&#125; 上面我们自定义的3个Task都位于TaskContainer中，Project中的tasks属性即表示该TaskContainer。我们可以显示这些信息 1234task showTasks &#123; println tasks.class println tasks.size()&#125; 输入如下 123class org.gradle.api.internal.tasks.DefaultTaskContainer_Decorated4:showTasks UP-TO-DATE 上面的DefaultTaskContainer_Decorated表示tasks类型，而4表示TaskContainer中包含4个自定义的Task(包含showTasks本身) 通过TaskContainer的create()方法创建Task build.gradle 123tasks.create(name: "hello4") &lt;&lt; &#123; println "hello4"&#125; Analyze 我们知道通过task()方法创建的Task都被存放在TaskContainer中，而Project又维护了一个TaskContainer类型的属性tasks，那么我们完全可以直接向TaskContainer里面添加Task。TaskContainer向我们提供了大量重载的create()方法用于添加Task 声明Task之间的依赖关系 build.gradle 123task hello5(dependsOn: hello4) &lt;&lt; &#123; println "hello5"&#125; 也可以先定义Task之后再声明依赖 12345task hello6 &lt;&lt; &#123; println "hello6"&#125;hello6.dependsOn hello5 配置Task build.gradle 1234task hello7 &lt;&lt; &#123; description = "this is hello7" println description&#125; 也可以通过闭包的方式类配置一个已有的Task 1234567task hello8 &lt;&lt; &#123; println description&#125;hello8 &#123; description = "this is hello8"&#125; Analyze Task除了执行操作之外，还可以包含多个Property Gradle为每个Task默认定义的Property有description，logger等 每一个特定的Task类型可以含有特定的Property，比如Copy的from和to 我们也可以动态地向Task中加入额外的Property Gradle在执行Task时分为两个阶段：首先是配置阶段，然后才是实际执行阶段。在执行hello8之前，Gradle会扫描整个build.gradle文档，将hello8的description设置为”this is hello8”，然后执行hello8 除了上面方式外，我们也可以通过Task的configure()方法完成Property的设置 build.gradle 1234567task hello9 &lt;&lt; &#123; println description&#125;hello9.configure &#123; description = "this is hello9"&#125; Analyze 实际上，通过闭包的方式配置Task在内部也是通过调用Task的configure()方法完成的]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-AOP请求处理]]></title>
    <url>%2F2017%2F04%2F30%2Fspringboot-unified-request-handing%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍AOP的使用 脚下留心 项目结构 12345678910--src/main/java----com.easy.app------HttpAspect.java------Program.java------User.java------UserController.java------UserRepository.java--src/main/resources----application.yml--build.gradle build.gradle 123456789101112apply plugin:'java'repositories&#123; maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;&#125;dependencies &#123; compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.4.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.4.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa', version: '1.4.2.RELEASE' compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.38'&#125; application.yml 12345678910111213server: port: 8002 context-path: /springbootwebspring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/dbuser?useSSL=true username: root password: 123456 jpa: hibernate: ddl-auto: update show-sql: true User.java 123456789101112131415161718@Entitypublic class User &#123; @Id @GeneratedValue private Integer id; private String name; private Integer age; public User()&#123; &#125; @Override public String toString() &#123; return "User [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125; UserController.java 1234567891011@RestControllerpublic class UserController &#123; @Autowired private UserRepository userRepository; @GetMapping(value="/users/getuser/&#123;id&#125;") public User findOne(@PathVariable("id") Integer id)&#123; return userRepository.findOne(id); &#125;&#125; Output 在浏览器输入http://localhost:8002/springbootweb/users/getuser/1，在控制台可以看到以下输出 12345678910112017-04-30 21:02:35.551 INFO 11096 --- [nio-8002-exec-1] o.a.c.c.C.[.[.[/springbootweb] : Initializing Spring FrameworkServlet 'dispatcherServlet'2017-04-30 21:02:35.551 INFO 11096 --- [nio-8002-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet 'dispatcherServlet': initialization started2017-04-30 21:02:35.571 INFO 11096 --- [nio-8002-exec-1] o.s.web.servlet.DispatcherServlet : FrameworkServlet 'dispatcherServlet': initialization completed in 20 ms2017-04-30 21:02:35.606 INFO 11096 --- [nio-8002-exec-1] com.easy.app.HttpAspect : url=http://localhost:8002/springbootweb/users/getuser/12017-04-30 21:02:35.606 INFO 11096 --- [nio-8002-exec-1] com.easy.app.HttpAspect : method=GET2017-04-30 21:02:35.606 INFO 11096 --- [nio-8002-exec-1] com.easy.app.HttpAspect : ip=0:0:0:0:0:0:0:12017-04-30 21:02:35.607 INFO 11096 --- [nio-8002-exec-1] com.easy.app.HttpAspect : class_method=com.easy.app.UserController.findOne2017-04-30 21:02:35.607 INFO 11096 --- [nio-8002-exec-1] com.easy.app.HttpAspect : args=1Hibernate: select user0_.id as id1_0_0_, user0_.age as age2_0_0_, user0_.name as name3_0_0_ from user user0_ where user0_.id=?2017-04-30 21:02:35.662 INFO 11096 --- [nio-8002-exec-1] com.easy.app.HttpAspect : 最后执行2017-04-30 21:02:35.662 INFO 11096 --- [nio-8002-exec-1] com.easy.app.HttpAspect : response=User [id=1, name=alen, age=6]]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-全局异常处理]]></title>
    <url>%2F2017%2F04%2F30%2Fspringboot-unified-exceptioni-handing%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍使用SpringBoot处理全局异常 脚下留心 项目结构 123456789101112--src/main/java----com.easy.app------ExceptionHandle------Program.java------User.java------UserController.java------UserException.java------UserRepository.java------UserService.java--src/main/resources----application.yml--build.gradle build.gradle 123456789101112apply plugin:'java'repositories&#123; maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;&#125;dependencies &#123; compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.4.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.4.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa', version: '1.4.2.RELEASE' compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.38'&#125; application.yml 12345678910111213server: port: 8002 context-path: /springbootwebspring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/dbuser?useSSL=true username: root password: 123456 jpa: hibernate: ddl-auto: update show-sql: true User.java 123456789101112131415161718@Entitypublic class User &#123; @Id @GeneratedValue private Integer id; private String name; private Integer age; public User()&#123; &#125; @Override public String toString() &#123; return "User [id=" + id + ", name=" + name + ", age=" + age + "]"; &#125; UserRepository.java 123public interface UserRepository extends JpaRepository&lt;User,Integer&gt;&#123;&#125; UserService.java 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserRepository userRepository; public void getAge(Integer id)&#123; User user =userRepository.findOne(id); if(user.getAge()&lt;10)&#123; throw new UserException("小学生你好"); &#125;else if(user.getAge()&gt;=10&amp;&amp;user.getAge()&lt;16)&#123; throw new UserException("初中生你好"); &#125; &#125;&#125; UserException.java 123456public class UserException extends RuntimeException&#123; public UserException(String msg) &#123; super(msg); &#125;&#125; ExceptionHandle.java 12345678910111213141516@ControllerAdvicepublic class ExceptionHandle &#123; private final static Logger logger=LoggerFactory.getLogger(ExceptionHandle.class); @ExceptionHandler(value=Exception.class) @ResponseBody public String handle(Exception e)&#123; if(e instanceof UserException)&#123; return "【异常错误】："+e.getMessage(); &#125;else&#123; return "【未知错误】："+e.getMessage(); &#125; &#125;&#125; UserController.java 1234567891011@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @GetMapping(value="/users/getAge/&#123;id&#125;") public void findOne(@PathVariable("id") Integer id)&#123; userService.getAge(id); &#125;&#125; Output 在浏览器输入http://localhost:8002/springbootweb/users/getAge/1，输出【异常错误】：小学生你好]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-表单验证]]></title>
    <url>%2F2017%2F04%2F30%2Fspringboot-form-validate%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍，如何用SpringBoot进行表单验证 脚下留心 项目结构 123456789--src/main/java----com.easy.app------Program.java------User.java------UserController.java------UserRepository.java--src/main/resources----application.yml--build.gradle build.gradle 123456789101112apply plugin:'java'repositories&#123; maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;&#125;dependencies &#123; compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.4.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.4.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa', version: '1.4.2.RELEASE' compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.38'&#125; application.yml 12345678910111213server: port: 8002 context-path: /springbootwebspring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/dbuser?useSSL=true username: root password: 123456 jpa: hibernate: ddl-auto: update show-sql: true User.java 123456789101112131415@Entitypublic class User &#123; @Id @GeneratedValue private Integer id; @Length(max=3,message="姓名长度不能超过3个字符") private String name; @Min(value=18,message="年龄不能小于18岁") private Integer age; public User()&#123; &#125; UserRepository.java 123public interface UserRepository extends JpaRepository&lt;User,Integer&gt;&#123;&#125; UserController.java 12345678910111213141516@RestControllerpublic class UserController &#123; @Autowired private UserRepository userRepository; @PostMapping(value="/addUser") public String add(@Valid User user,BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123; return bindingResult.getFieldError().getDefaultMessage(); &#125;else&#123; userRepository.save(user); return "添加成功"; &#125; &#125;&#125; Output 请求地址为http://localhost:8002/springbootweb/addUser， 如果请求的body中的name为lily，会返回姓名长度不能超过3个字符 如果请求的body中age为17，会返回年龄不能小于18岁]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cheat-sheet-good-things]]></title>
    <url>%2F2017%2F04%2F28%2Fcheat-sheet-work-efficient-tools%2F</url>
    <content type="text"><![CDATA[前言本文主要记录一些自己常用的工具 开发工具 Pycharm 开发Python的利器，代码的智能提示，方便查看源代码，代码的调试跟踪都足够强大 Visual Studio 2013 开发C#的利器，不管是Winform，WPF，Web，调试真的很牛逼。必备插件：Resharper Eclipse 开发Java的利器，免安装，集各种插件与一身。必备插件：Gradle IDE，M2，Spring Suit Tools，Properties Editor，SubClipse，EGit，JSON Editor MarkDownPad 写MardDown的利器，不足之处是不支持一些高级语法。可以结合有道云笔记。 办公必备 Everything 文件搜索工具，快速 Cmder windows下dos的替代品，选中复制，右键黏贴 Oracle VM VirtualBox 轻量级的虚拟机软件，对应一些数据库可以安装在上面，秒开机。推荐和重量级的VMWare Station一起使用。 写文章常用的一些符号12345└── src ├── main │ └── java └── test └── java 优秀博客http://www.cnblogs.com/davenkin/p/gradle-spring-boot.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gradle系列-快速开始]]></title>
    <url>%2F2017%2F04%2F28%2Fgradle-getstart%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍几个Gradle的快速例子 脚下留心使用Task的默认类型 build.gradle 123task helloWorld &lt;&lt; &#123; println "Hello World!"&#125; Output 1gradle helloWorld Analyze 默认情况下，Gradle将当前的build.gradle文件作为项目的构建文件。 上面例子，我们创建了一个名为helloWorld的Task，在执行gradle命令时，我们指定执行这个helloWorld Task。* 这里的helloWorld是一个DefaultTask类型的对象，这也是定义一个Task时的默认类型 显示声明Task类型 项目结构 123--build.gradle--xml----aa.txt build.gradle 1234task copyFile(type: Copy) &#123; from "xml" into "destination"&#125; Output 1gradle copyFile Analyze 这是一个显示的声明Task的类型，这个Task的类型为Copy Task之间的依赖关系 build.gradle 1234567task taskB &lt;&lt; &#123; println "taskB"&#125;task taskA(dependsOn: taskB) &#123; println "taskA"&#125; Output 1gradle taskA Analyze Task之间可以存在依赖关系，上面例子中taskA依赖与taskB，Gradle会先执行taskB，然后再执行taskA Gradle提供常用的Task查看Project中所有的Task 12gradle tasks --allgradle tasks 查看Project中所有的Property 1gradle properties]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC系列-基于注解的开发]]></title>
    <url>%2F2017%2F04%2F25%2Fspringmvc-annotation%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍基于注解的SpringMVC开发 脚下留心 项目结构 123456789101112--src/main/java----com.easy.controllers------UserController.java--springmvc.xml--WebContent----views------user--------hello.jsp--------index.jsp----WEB-INF------web.xml--build.gradle springmvc.xml 1234567891011121314151617&lt;!-- 注解扫描 --&gt;&lt;context:component-scan base-package="com.easy.*"&gt;&lt;/context:component-scan&gt;&lt;!-- 注解处理器映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt;&lt;!-- 注解处理器适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;&lt;/bean&gt;&lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 自定义的Controller --&gt;&lt;!-- 使用@Controller方式，所有不需要单独定义 --&gt; UserController.java 123456789101112131415161718192021@Controllerpublic class UserController &#123; @RequestMapping("add") public String add()&#123; System.out.println("add..."); return "user/index"; &#125; @RequestMapping(value="/edit.do") public String edit()&#123; System.out.println("edit..."); return "user/index"; &#125; @RequestMapping(value=&#123;"/delete.do","/Delete.do"&#125;) public String delete()&#123; System.out.println("delete..."); return "user/index"; &#125;&#125; RequestMapping的几种用法 requestMapping(“add”) requestMapping(“/add.do”) requestMapping(value=”/add.do”) requestMapping(value=”/add.do”,method=RequestMethod.GET) requestMapping(value=”/add.do”,method={RequestMethod.GET,RequestMethod.POST})]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC系列-时间类型转换]]></title>
    <url>%2F2017%2F04%2F25%2Fspringmvc-time-transform%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍如何使用SpringMVC的类型转换 脚下留心 项目结构 12345678910111213--src/main/java----com.easy.controllers------HomeController.java------User.java--springmvc.xml--WebContent----views------home--------hello.jsp--------index.jsp----WEB-INF------web.xml--build.gradle User.java 12345678public class User &#123; private String userName; private Date createTime; @Override public String toString() &#123; return "User [userName=" + userName + ", createTime=" + createTime + "]"; &#125; hello.jsp 1234567&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/hello.do" method="post"&gt; UserName：&lt;input type="text" name="UserName" value="杰克"/&gt;&lt;br/&gt; CreateTime:&lt;input type="text" name="CreateTime" value="2017/1/1"/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt;&lt;/body&gt; HomeController.java 1234567891011121314151617public class HomeController extends AbstractCommandController&#123; public HomeController() &#123; this.setCommandClass(User.class); &#125; @Override protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object command, BindException errors) throws Exception &#123; User user=(User)command; System.out.println(user); ModelAndView mv=new ModelAndView(); mv.addObject("message","everyone"); mv.setViewName("home/index"); return mv; &#125;&#125; Output 如果我们在日期处填了2017/1/1，在控制台可以输出时间 如果我们在日期处填了2017-1-1，在控制台输出的时间为null Deal 在HelloController中添加以下方法 12345678910111213@Overrideprotected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception &#123; String str = request.getParameter("CreateTime"); if(str.contains("/"))&#123; binder.registerCustomEditor(Date.class, new CustomDateEditor( new SimpleDateFormat("yyyy/MM/dd"), true)); &#125;else&#123; binder.registerCustomEditor(Date.class, new CustomDateEditor( new SimpleDateFormat("yyyy-MM-dd"), true)); &#125;&#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC系列-乱码问题]]></title>
    <url>%2F2017%2F04%2F25%2Fspringmvc-messy-code%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍SpringMVC中乱码问题的处理 GET请求乱码 HomeController.java 123456789101112public class HomeController implements Controller&#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv=new ModelAndView(); String username=request.getParameter("username"); System.out.println(username); mv.addObject("message","everyone"); mv.setViewName("home/index"); return mv; &#125;&#125; Output 在浏览器中输入http://localhost:8989/easy-springmvc-005/hello.do?username=杰克在控制台中会输出乱码 Deal 找到Tomcat下面的server.xml找到以下节点1&lt;Connector connectionTimeout="20000" port="8989" protocol="HTTP/1.1" redirectPort="8443"/&gt; 修改后的节点信息如下 1&lt;Connector URIEncoding="UTF-8" connectionTimeout="20000" port="8989" protocol="HTTP/1.1" redirectPort="8443"/&gt; POST提交乱码 项目结构 123456789101112--src/main/java----com.easy.controllers------HomeController.java--springmvc.xml--WebContent----views------home--------hello.jsp--------index.jsp----WEB-INF------web.xml--build.gradle web.xml 1234567891011121314&lt;!-- springmvc前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 拦截do后缀的请求 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; HomeController.java 123456789101112public class HomeController implements Controller&#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv=new ModelAndView(); String username=request.getParameter("username"); System.out.println(username); mv.addObject("message","everyone"); mv.setViewName("home/index"); return mv; &#125;&#125; hello.jsp 123456&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/hello.do" method="post"&gt; username:&lt;input type="text" name="username" value="肉丝"/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt;&lt;/body&gt; Output 在浏览器中输入http://localhost:8989/easy-springmvc-005/views/home/hello.jsp，然后点击提交，在控制台会输出乱码 Deal 在web.xml中添加以下配置 12345678910111213&lt;!-- Post乱码处理 --&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC系列-处理器适配器]]></title>
    <url>%2F2017%2F04%2F25%2Fspringmvc-handler-adapter%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍SpringMVC提供的两种处理器适配器 默认处理器适配器如果在springmvc.xml中不配置处理器适配器，默认会使用SimpleControllerHandlerAdapter springmvc.xml 1234567891011121314&lt;!-- 处理器映射器 --&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 处理器适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;&lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 自定义的Controller --&gt;&lt;bean name="/hello.do" class="com.easy.controllers.HomeController"&gt;&lt;/bean&gt; HomeController.java 1234567891011121314public class HomeController implements Controller&#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv=new ModelAndView(); mv.addObject("message","everyone"); //返回物理视图，不需要配置视图解析器 //mv.setViewName("/WEB-INF/jsp/hello.jsp"); //返回逻辑视图，需要配置视图解析器 mv.setViewName("home/index"); return mv; &#125;&#125; SimpleControllerHandlerAdapter.java 12345678910111213141516171819202122public class SimpleControllerHandlerAdapter implements HandlerAdapter &#123; //该处理器适配器是不是Controller的实例 public boolean supports(Object handler) &#123; return (handler instanceof Controller); &#125; //如果是Controller的实例，就强转为Controller，并调用handleRequest()方法 public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return ((Controller) handler).handleRequest(request, response); &#125; public long getLastModified(HttpServletRequest request, Object handler) &#123; if (handler instanceof LastModified) &#123; return ((LastModified) handler).getLastModified(request); &#125; return -1L; &#125;&#125; Http处理器适配器 springmvc.xml 1234567891011121314&lt;!-- 处理器映射器 --&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 处理器适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt;&lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 自定义的Controller --&gt;&lt;bean name="/order.do" class="com.easy.controllers.OrderController"&gt;&lt;/bean&gt; OrderController.java 123456789public class OrderController implements HttpRequestHandler&#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute("message", "hello jack"); request.getRequestDispatcher("/views/home/index.jsp").forward(request, response); &#125;&#125; HttpRequestHandlerAdapter.java 1234567891011121314151617181920212223public class HttpRequestHandlerAdapter implements HandlerAdapter &#123; //该处理器适配器是不是HttpRequestHandler的实例 public boolean supports(Object handler) &#123; return (handler instanceof HttpRequestHandler); &#125; //如果是HttpRequestHandler的实例，就强转为HttpRequestHandler，并调用handleRequest()方法 public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; ((HttpRequestHandler) handler).handleRequest(request, response); return null; &#125; public long getLastModified(HttpServletRequest request, Object handler) &#123; if (handler instanceof LastModified) &#123; return ((LastModified) handler).getLastModified(request); &#125; return -1L; &#125;&#125; 总结以上两种处理器适配器，都实现了一个公共的接口HandlerAdapter HandlerAdapter.java 12345678910111213141516171819202122public interface HandlerAdapter &#123; /** * Given a handler instance, return whether or not this HandlerAdapter can * support it. Typical HandlerAdapters will base the decision on the handler * type. HandlerAdapters will usually only support one handler type each. */ boolean supports(Object handler); /** * Use the given handler to handle this request. * The workflow that is required may vary widely. */ ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; /** * Same contract as for HttpServlet's &#123;@code getLastModified&#125; method. * Can simply return -1 if there's no support in the handler class. */ long getLastModified(HttpServletRequest request, Object handler);&#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC系列-处理器映射器]]></title>
    <url>%2F2017%2F04%2F25%2Fspringmvc-handler-mapping%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍SpringMVC提供的三种处理器映射器 默认处理器映射器根据请求的url，到ControllerBean的name属性找到匹配的Controller springmvc.xml 1234567891011121314&lt;!-- 处理器映射器 --&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 处理器适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;&lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 自定义的Controller --&gt;&lt;bean name="/hello.do" class="com.easy.controllers.HomeController"&gt;&lt;/bean&gt; Output 在浏览器访问http://localhost:8989/easy-springmvc-002/hello.do，可映射到HomeController 简单url处理器映射器根据请求的url，到处理器映射器下的mappings属性下找到对应的key的value值，再根据value到ControllerBean中找到对应的id springmvc.xml 123456789101112131415161718192021222324 &lt;!-- 处理器映射器 --&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/aHello.do"&gt;homeController&lt;/prop&gt; &lt;prop key="/bHello.do"&gt;homeController&lt;/prop&gt; &lt;prop key="/cHello.do"&gt;homeController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 处理器适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 自定义的Controller --&gt; &lt;bean id="homeController" class="com.easy.controllers.HomeController"&gt;&lt;/bean&gt; &lt;/beans&gt; Output 在浏览器输入http://localhost:8989/easy-springmvc-002/aHello.do，可获取HomeController 在浏览器输入http://localhost:8989/easy-springmvc-002/bHello.do，可获取HomeController 在浏览器输入http://localhost:8989/easy-springmvc-002/cHello.do，可获取HomeController 类名处理器映射器根据 类名.do 来获取Controller springmvc.xml 1234567891011121314&lt;!-- 处理器映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"&gt;&lt;/bean&gt;&lt;!-- 处理器适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt;&lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 自定义的Controller --&gt;&lt;bean class="com.easy.controllers.HomeController"&gt;&lt;/bean&gt; Output 在浏览器中输入http://localhost:8989/easy-springmvc-003/homeController.do可获取HomeController 类名.do，类名的首字母必须小写]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-JPA]]></title>
    <url>%2F2017%2F04%2F24%2Fspringboot-jpa%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍SpringBoot的数据库操作 ## 项目结构 123456789--src/main/java----com.easy.app------Program.java------User.java------UserController.java------UserRepository.java--src/main/resources----application.yml--build.gradle build.gradle 123456789101112apply plugin:'java'repositories&#123; maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;&#125;dependencies &#123; compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.4.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.4.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-jpa', version: '1.4.2.RELEASE' compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.38'&#125; application.yml 12345678910111213server: port: 8002 context-path: /springbootwebspring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/dbuser?useSSL=true username: root password: 123456 jpa: hibernate: ddl-auto: update show-sql: true User.java 1234567891011@Entitypublic class User &#123; @Id @GeneratedValue private Integer id; private String name; private Integer age; public User()&#123; &#125; UserRepository.java 123public interface UserRepository extends JpaRepository&lt;User,Integer&gt;&#123;&#125; UserController.java 注入Repository层 1234567891011@RestControllerpublic class UserController &#123; @Autowired private UserRepository userRepository; @GetMapping(value="/users") public List&lt;User&gt;userList()&#123; return userRepository.findAll(); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC系列-入门案例]]></title>
    <url>%2F2017%2F04%2F24%2Fspringmvc-getstart%2F</url>
    <content type="text"><![CDATA[前言本文主要通过一个SpringMVC项目，来学习SpringMVC的执行过程 脚下留心构建项目 项目结构 1234567891011--src/main/java----com.easy.controllers------HomeController.java--springmvc.xml--WebContent----views------home--------index.jsp----WEB-INF------web.xml--build.gradle build.gradle 12345678910111213141516apply plugin:'war'apply plugin:'eclipse-wtp'sourceCompatibility = 1.7 // 设置 JDK 版本webAppDirName = 'WebContent' // 设置 WebApp 根目录repositories&#123; maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;&#125;dependencies&#123; compile group: 'org.springframework', name: 'spring-context', version: '3.2.3.RELEASE' compile group: 'org.springframework', name: 'spring-webmvc', version: '3.2.3.RELEASE' compile group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0' compile group: 'javax.servlet', name: 'jstl', version: '1.2' compile group: 'javax.servlet.jsp', name: 'javax.servlet.jsp-api', version: '2.2.1'&#125; web.xml 123456789101112131415&lt;!-- springmvc前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 拦截.do后缀的请求 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; load-on-startup：启动容器时初始化DispatcherServlet url-pattern：拦截哪些请求给DispatcherServlet处理 contextConfigLocation：springmvc配置文件位置，默认为/WEB-INF/[servlet-name]-servlet.xml springmvc.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;!-- 处理器映射器 --&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- 处理器适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 自定义Controller --&gt; &lt;bean name="/hello.do" class="springmvc001.HomeController"&gt;&lt;/bean&gt; &lt;/beans&gt; springmvc.xml需要配置三个信息：处理器映射器、处理器适配器、视图解析器 HomeController.java 1234567891011121314public class HomeController implements Controller&#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ModelAndView mv=new ModelAndView(); mv.addObject("message","everyone"); //返回物理视图，不需要配置视图解析器 //mv.setViewName("views/home/index.jsp"); //返回逻辑视图，需要配置视图解析器 mv.setViewName("home/index"); return mv; &#125;&#125; index.jsp 123&lt;body&gt; Hello $&#123;requestScope.message &#125;&lt;/body&gt; Output 在浏览器输入http://localhost:8989/easy-springmvc/hello.do及可看到Hello everyone。 分析 浏览器请求http://localhost:8989/easy-springmvc/hello.do。根据web.xml的配置，.do的请求会被拦截下来由*DispatcherServlet来处理 前端控制器接受请求，并将请求转发给处理器映射器 处理器映射器根据配置规则，解析出HomeController，并将控制器返回给前端控制器 前端控制器接受请求，并将HomeController转发给处理器适配器 处理器适配器接收HomeController进行处理，并返回ModelAndView给前端控制器 前端控制器接受请求，并将ModelAndView转发给视图解析器 视图解析器接收ModelAndView进行处理，并返回逻辑视图View给前端控制器 渲染视图]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-Controller]]></title>
    <url>%2F2017%2F04%2F23%2Fspringboot-controller%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍Controller的使用 项目结构注意启动类必须在最顶层，本次项目中的启动类是Program.java 123456--src/main/java----com.easy------Program.java----com.easy.controllers------HomeController.java--build.gradle 引入依赖环境12compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.4.2.RELEASE'compile group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.4.2.RELEASE' 编写启动类123456@SpringBootApplicationpublic class Program &#123; public static void main(String[] args) &#123; SpringApplication.run(Program.class, args); &#125;&#125; 编写控制层12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@RestController@RequestMapping("/hello")public class HomeController &#123; /* * 访问http://localhost:8080/hello * 访问http://localhost:8080/hello/ */ @RequestMapping public String hello() &#123; return "Hello Spring-Boot"; &#125; /* * 访问http://localhost:8080/hello/info?name=jack * 输出&#123;"name":"jack"&#125; */ @RequestMapping("/info") public Map&lt;String, String&gt; getInfo(@RequestParam String name) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("name", name); return map; &#125; /* * 访问http://localhost:8080/hello/list * 输出[&#123;"name":"Shanhy-1"&#125;,&#123;"name":"Shanhy-2"&#125;] */ @RequestMapping("/list") public List&lt;Map&lt;String, String&gt;&gt;getList()&#123; List&lt;Map&lt;String, String&gt;&gt;list=new ArrayList&lt;&gt;(); Map&lt;String, String&gt;map=null; for(int i=1;i&lt;=2;i++)&#123; map=new HashMap&lt;&gt;(); map.put("name", "Shanhy-"+i); list.add(map); &#125; return list; &#125; /* * 访问http://localhost:8080/hello/get/1 * 输出Rose */ @RequestMapping(value="/get/&#123;id&#125;") public String getOne(@PathVariable(value="id",required=true)Integer id)&#123; List&lt;String&gt;list=new ArrayList&lt;&gt;(); list.add("Jack"); list.add("Rose"); return list.get(id); &#125;&#125; @RestController等同于@Controller和@ResponseBody的组合 @RequestMapping用来配置url映射 @RequestParam用来匹配请求参数，可带参数public String index(@RequestParam(value=&quot;name&quot;,required=true,defaultValue=&quot;kim&quot;) String username) @PathVariable用来匹配请求路径，可带参数public String index(@PathVariable(value=&quot;id&quot;,required=true) Integer myId) 组合注解什么是组合注解，就是把省略了请求方式，如：@RequestMapping(value=&quot;/get/{id}&quot;,method=RequestMethod.GET)等价与@GetMapping(value=&quot;/get/{id}&quot;) 其他组合注解 @PostMapping @DeleteMapping @PutMapping]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-项目属性配置]]></title>
    <url>%2F2017%2F04%2F23%2Fspringboot-config-web-info%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍SpringBoot的项目的一些配置 两种配置使用properties文件 项目结构 1234567--src/main/java----com.easy.a.getstart------HomeController.java------Program.java--src/main/resources----application.properties--build.gradle Program.java 123456@SpringBootApplicationpublic class Program &#123; public static void main(String[] args) &#123; SpringApplication.run(Program.class, args); &#125;&#125; HomeController.java 1234567@RestControllerpublic class HomeController &#123; @RequestMapping(value="/index") public String index()&#123; return "Hello Spring Boot"; &#125;&#125; application.properties 12server.port=8001server.context-path=/springbootweb Output 在浏览器中输入http://localhost:8001/springbootweb/index即可看到效果 使用application.yml 项目结构 1234567--src/main/java----com.easy.a.getstart------HomeController.java------Program.java--src/main/resources----application.properties--build.gradle Program.java 123456@SpringBootApplicationpublic class Program &#123; public static void main(String[] args) &#123; SpringApplication.run(Program.class, args); &#125;&#125; HomeController.java 1234567@RestControllerpublic class HomeController &#123; @RequestMapping(value="/index") public String index()&#123; return "Hello Spring Boot"; &#125;&#125; application.yml 123server: port: 8002 context-path: /springbootweb Output 在浏览器中输入http://localhost:8002/springbootweb/index即可看到效果 项目属性配置@Vaule配置 项目结构 1234567--src/main/java----com.easy.a.getstart------HomeController.java------Program.java--src/main/resources----application.yml--build.gradle application.yml 123456server: port: 8002 context-path: /springbootwebperson: username: jack age: 20 HomeController.java 1234567891011121314@RestControllerpublic class HomeController &#123; @Value("$&#123;person.username&#125;") private String username; @Value("$&#123;person.age&#125;") private Integer age; @RequestMapping(value="/index") public String index()&#123; return username+":"+age; &#125;&#125; 配置文件中调用配置 项目结构 1234567--src/main/java----com.easy.a.getstart------HomeController.java------Program.java--src/main/resources----application.yml--build.gradle application.yml 1234567server: port: 8002 context-path: /springbootwebperson: username: jack age: 20 content: "用户名：$&#123;person.username&#125;,年龄：$&#123;person.age&#125;" HomeController.java 1234567891011@RestControllerpublic class HomeController &#123; @Value("$&#123;content&#125;") private String content; @RequestMapping(value="/index") public String index()&#123; return content; &#125;&#125; 与Pojo组合使用 项目结构 12345678--src/main/java----com.easy.a.getstart------HomeController.java------Person.java------Program.java--src/main/resources----application.yml--build.gradle Person.java 12345@Component@ConfigurationProperties(prefix="person")public class Person &#123; private String username; private Integer age; application.yml 123456server: port: 8002 context-path: /springbootwebperson: username: jack age: 20 HomeController.java 1234567891011@RestControllerpublic class HomeController &#123; @Autowired private Person person; @RequestMapping(value="/index") public String index()&#123; return person.getUsername()+":"+person.getAge(); &#125;&#125; 配置文件组合使用 项目结构 12345678910--src/main/java----com.easy.a.getstart------HomeController.java------Person.java------Program.java--src/main/resources----application-one.yml----application-two.yml----application.yml--build.gradle application.yml 123spring: profiles: active: two application-one.yml 123456server: port: 8001 context-path: /springbootwebperson: username: jack age: 20 application-two.yml 123456server: port: 8002 context-path: /springbootwebperson: username: rose age: 18]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript类型转换]]></title>
    <url>%2F2017%2F04%2F21%2Fjavascript-string-to-num%2F</url>
    <content type="text"><![CDATA[前言本文主要记录一些JavaScript中的数值转换 转换函数 js提供了parseInt()和parseFloat()两个转换函数。 前者把值类型转换成整数，后者把值转换成浮点数。 parseInt()的基本用法 1234console.log(parseInt("1234blue")); //1234console.log(parseInt("0xA")); //10console.log(parseInt("22.5")); //22console.log(parseInt("blue")); //NaN parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。 1234console.log(parseInt("10",2)); //转二进制，2console.log(parseInt("10",8)); //转八进制，8console.log(parseInt("10",16)); //转十六进制，16console.log(parseInt("10",10)); //转十进制，10 parseFloat()方法与parseInt()方法相似，只不过字符串必须以十进制形式表示浮点数。且parseFloat()没有基模式 12345console.log(parseFloat("1234blue")); //1234console.log(parseFloat("0xA")); //0console.log(parseFloat("22.5")); //22.5console.log(parseFloat("22.5.6")); //22.5console.log(parseFloat("blue")); //NaN 强制类型转换 使用强制类型转换可以访问特定的值，即使它是另一种类型 ECMAScript提供3种强制类型转换 Boolean(value)：把给定的值转换 Number(value)：把给定的值转换成数字(可以是整数或浮点数) String(value)：把给定的值转换成字符串 用这三个函数，将创建一个新值，存放由原始值直接转换成的值 Boolean()的使用 1234567console.log(Boolean("")); //false，空字符串console.log(Boolean("hi")); //true，不为空的字符串console.log(Boolean(100)); //true，不为0的数值console.log(Boolean(null)); //falseconsole.log(Boolean(0)); //falseconsole.log(Boolean(new Object())); //trueconsole.log(Boolean(undefined)); //false，未定义 Number()的使用 123456789console.log(Number(false)); //0console.log(Number(true)); //1console.log(Number(undefined)); //NaNconsole.log(Number(null)); //0console.log(Number("5.5")); //5.5console.log(Number("56")); //56console.log(Number("5.6.7")); //NaNconsole.log(Number(new Object())); //NaNconsole.log(Number(100)); //100 String()的使用 1234console.log(String(null)); //nullconsole.log(String(true)); //trueconsole.log(String(undefined)); //undefinedconsole.log(String(new Object())); //[object Object] 利用js变量弱类型转换123var str ="012.345";var x=str-0;console.log(typeof(x));//number]]></content>
      <categories>
        <category>HTNL</category>
      </categories>
      <tags>
        <tag>HTNL</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-common-method]]></title>
    <url>%2F2017%2F04%2F20%2Fspring-common-method%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍Spring一些常用方法 文件资源操作]]></content>
  </entry>
  <entry>
    <title><![CDATA[deal-sqlserver-log-overflow]]></title>
    <url>%2F2017%2F04%2F18%2Fdeal-sqlserver-log-overflow%2F</url>
    <content type="text"><![CDATA[前言本文主要是一次删除SqlServer数据库Log的操作记录。 发现问题今天备份了客户的数据库，还原之后竟然有20多个G，看了下还原后的文件，.ldf文件竟然有10G。然后就开始了删库操作 跟我学 找出指定数据库的log名称 12USE gms_hbgaSELECT file_id, name FROM sys.database_files 根据查询出的log名，开始删库 12USE gms_hbgaDBCC SHRINKFILE (N'GMS_log' , 11, TRUNCATEONLY) 也可以让该数据库不产生log 123USE [master]ALTER DATABASE gms_hbga SET RECOVERY SIMPLE WITH NO_WAITALTER DATABASE gms_hbga SET RECOVERY SIMPLE --简单模式 当然也可以还原 123USE [master]ALTER DATABASE gzl SET RECOVERY FULL WITH NO_WAITALTER DATABASE gzl SET RECOVERY FULL --还原为完全模式]]></content>
      <categories>
        <category>Deal-Problem</category>
      </categories>
      <tags>
        <tag>SqlServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-how-to-manager-source-code]]></title>
    <url>%2F2017%2F04%2F09%2Fhexo-how-to-manager-source-code%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你，我是如何管理我的博客源代码 发现问题我自己有两台笔记本，一台是公司分配的用于办公的，一台是我个人PC。不管之前在博客园还是现在在个人Github上，我写代码或发表文章，都是即兴的，就是我想到可以把这个问题记录一下，然后就马上动手写。但是这有个问题，比如我在Work-PC上发表了一篇文章，但是我会我住宿时，我的Person-PC上没有这篇文章的源代码。我之前的操作是，每次写好一篇然后，压缩拷贝到U盘。 分析问题由于Hexo的机制，每次上传GitHub都只会上传编译后的文件。对于源代码文件是不上传的。然后我就想到了在用一个新的仓库来保存我的配置源代码。还有个问题，就是我使用的Next主题的作者改变了主题，我也要更新。我就又用一个仓库，来保存博客主题。这样我总共有了三个仓库。 仓库A保存发布的代码 仓库B保存我文章的源代码 仓库C保存我使用主题的源代码 解决问题根据上面的分析，我的源代码管理问题解决了。以后如果我回家，在家的台式机上我只要这么操作就可以。 第一步：获取仓库A： 1git clone https://github.com/Kimisme/myblog.git 第二步：下载主题代码 1git clone https://github.com/Kimisme/hexo-theme-next themes/next 第三步：hexo配置 12345npm install -g hexo -clinpm installhexo cleanhexo ghexo s]]></content>
      <categories>
        <category>Deal-Problem</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlserver-transaction]]></title>
    <url>%2F2017%2F04%2F07%2Fsqlserver-transaction%2F</url>
    <content type="text"><![CDATA[前言本文主要介绍下事务的知识 概念什么是事务 事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。 事务的四大特性 原子性(Atomicity):事务中所有的操作是不可分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。 一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致，如转账业务，前后余额和不变。 隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。 持久性（Durability）：一个事务一旦提交，它对数据库中的数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响 事务引发的问题如果不考虑隔离性，就可能发生：脏读，不可重复读，幻读的问题。 脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据无效。 不可重复读：在同一个事务中，多次读取同一个数据返回的结果不同。 幻读：一个事务读取了几行记录后，另一个事务插入了一些记录。后来查询中，第一个事务就会发现有些原来没有的记录。 事务的隔离级别事务的隔离级别是为了防止脏读、不可重复读、幻读问题的发生。 事务隔离级别(四种) 隔离级别 含义 DEFAULT 使用后端数据库默认的隔离级别(Spring中的选择项) READ_UNCOMMITED 允许你读取还未提交的改变的数据。可能导致脏、幻、不可重复读 READ_COMMITTED 允许在并发事务已经提交后读取。可防止脏读，但幻读和不可重复读仍可发生 REPEATABLE_READ 对相同字段的多次读取是一致的，除非数据库被事务本身改变。可防脏、不可重复读，但幻读仍可能发生 SERIALIZABLE 完全服从ACID的隔离级别，确保不发生脏、幻、不可重复读。这在所有的隔离级别中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的 默认级别 Spring有一个default隔离级别，底层数据库用的哪个隔离级别，Spring就用什么隔离级别 MySql默认是REPEATABLE_READ Oracle默认是READ_COMMITTED 不同隔离级别可解决什么问题及会出现什么问题 隔离级别 脏读 不可重复读 幻读 读未提交:READ_UNCOMMITED 读已提交:READ_COMMITTED 不可能发生 可重复读:REPEATABLE_READ 不可能发生 不可能发生 可串行化:SERIALIZABLE 不可能发生 不可能发生 不可能发生 Spring中的事务隔离级别配置 1.编程式配置 2.声明式配置-基于AOP 3.声明式配置-基于注解 事务的传播行为(7种) 事务传播行为类型 说明 PROPAGATION_REQUIRED 支持当前事务，如果不存在就新建一个 PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就不使用事务 PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常 PROPAGATION_REQUIREDS_NEW 如果有事务存在，挂起当前事务，创建一个新的事务 PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务 PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常 PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hibernate系列-criteria查询]]></title>
    <url>%2F2017%2F04%2F01%2Fhibernate-criteria%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你，如何使用criteria查询 跟我学 项目结构 1234567--src/main/java----com.easy.c_hql------HibernateUtils.java------TestApp.java------User.java------hibernate.cfg.xml------User.hbm.xml User.java 1234public class User &#123; private Integer id; private String username; private Integer age; User.hbm.xml 123456789101112&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.easy.d_criteria.User" table="t_user"&gt; &lt;id name="id" column="ID"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="username" column="UserName"&gt;&lt;/property&gt; &lt;property name="age" column="Age"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; hibernate.cfg.xml 1234567891011121314151617&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;123456&lt;/property&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;mapping resource="com/easy/d_criteria/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; HibernateUtils.java 1234567891011121314151617181920212223242526public class HibernateUtils &#123; private static SessionFactory sessionFactory; static&#123; URL url=HibernateUtils.class.getClass().getResource("/com/easy/d_criteria/hibernate.cfg.xml"); Configuration conf=new Configuration().configure(url); sessionFactory =conf.buildSessionFactory(); Runtime.getRuntime().addShutdownHook(new Thread( new Runnable() &#123; @Override public void run() &#123; System.out.println("虚拟机关闭，释放资源"); sessionFactory.close(); &#125; &#125;)); &#125; public static Session openSession()&#123; return sessionFactory.openSession(); &#125; public static Session getCurrentSession()&#123; return sessionFactory.getCurrentSession(); &#125;&#125; UT 查询多行数据 1234567891011public void test_query_multi_rows()&#123; Session session = HibernateUtils.openSession(); Criteria criteria =session.createCriteria(User.class); criteria.add(Restrictions.like("username", "%rose%")); List&lt;User&gt;list=criteria.list(); System.out.println(list); session.close(); &#125; 查询单行数据 1234567891011public void test_query_single_row()&#123; Session session = HibernateUtils.openSession(); Criteria criteria =session.createCriteria(User.class); criteria.add(Restrictions.eq("id", 1)); User user =(User)criteria.uniqueResult(); System.out.println(user); session.close(); &#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate系列-hql查询]]></title>
    <url>%2F2017%2F04%2F01%2Fhibernate-hql%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你，如何使用hql查询语句 跟我学 项目结构 1234567--src/main/java----com.easy.c_hql------HibernateUtils.java------TestApp.java------User.java------hibernate.cfg.xml------User.hbm.xml User.java 1234public class User &#123; private Integer id; private String username; private Integer age; User.hbm.xml 123456789101112&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.easy.c_hql.User" table="t_user"&gt; &lt;id name="id" column="ID"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="username" column="UserName"&gt;&lt;/property&gt; &lt;property name="age" column="Age"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; hibernate.cfg.xml 1234567891011121314151617&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;123456&lt;/property&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;mapping resource="com/easy/c_hql/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; HibernateUtils.java 1234567891011121314151617181920212223242526public class HibernateUtils &#123; private static SessionFactory sessionFactory; static&#123; URL url=HibernateUtils.class.getClass().getResource("/com/easy/c_hql/hibernate.cfg.xml"); Configuration conf=new Configuration().configure(url); sessionFactory =conf.buildSessionFactory(); Runtime.getRuntime().addShutdownHook(new Thread( new Runnable() &#123; @Override public void run() &#123; System.out.println("虚拟机关闭，释放资源"); sessionFactory.close(); &#125; &#125;)); &#125; public static Session openSession()&#123; return sessionFactory.openSession(); &#125; public static Session getCurrentSession()&#123; return sessionFactory.getCurrentSession(); &#125;&#125; UT 查询多行数据 123456789public void test_query_multi_rows()&#123; Session session = HibernateUtils.openSession(); Query query = session.createQuery("from com.easy.c_hql.User"); List&lt;User&gt;list=query.list(); System.out.println(list); session.close(); &#125; 查询单行数据 123456789public void test_query_single_row()&#123; Session session = HibernateUtils.openSession(); Query query = session.createQuery("from com.easy.c_hql.User u where u.id=1"); User user =(User)query.uniqueResult(); System.out.println(user); session.close(); &#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate系列-CRUD]]></title>
    <url>%2F2017%2F04%2F01%2Fhibernate-crud%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你，如何使用Hibernate做增删改查 跟我学 项目结构 1234567--src/main/java----com.easy.b_crud------HibernateUtils.java------TestApp.java------User.java------hibernate.cfg.xml------User.hbm.xml User.java 1234public class User &#123; private Integer id; private String username; private Integer age; User.hbm.xml 123456789101112&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.easy.b_crud.User" table="t_user"&gt; &lt;id name="id" column="ID"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="username" column="UserName"&gt;&lt;/property&gt; &lt;property name="age" column="Age"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; hibernate.cfg.xml 1234567891011121314151617&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;123456&lt;/property&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;mapping resource="com/easy/b_crud/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; HibernateUtils.java 1234567891011121314151617181920212223242526public class HibernateUtils &#123; private static SessionFactory sessionFactory; static&#123; URL url=HibernateUtils.class.getClass().getResource("/com/easy/b_crud/hibernate.cfg.xml"); Configuration conf=new Configuration().configure(url); sessionFactory =conf.buildSessionFactory(); Runtime.getRuntime().addShutdownHook(new Thread( new Runnable() &#123; @Override public void run() &#123; System.out.println("虚拟机关闭，释放资源"); sessionFactory.close(); &#125; &#125;)); &#125; public static Session openSession()&#123; return sessionFactory.openSession(); &#125; public static Session getCurrentSession()&#123; return sessionFactory.getCurrentSession(); &#125;&#125; 测试 增 123456789101112public void test_add()&#123; Session session = HibernateUtils.openSession(); session.beginTransaction(); User user =new User(); user.setUsername("rose"); user.setAge(17); session.save(user); session.getTransaction().commit(); session.close(); &#125; 改 12345678910111213public void test_update()&#123; Session session = HibernateUtils.openSession(); session.beginTransaction(); User user =new User(); user.setId(1); user.setUsername("bigJack"); user.setAge(19); session.update(user); session.getTransaction().commit(); session.close(); &#125; 删 1234567891011public void test_delete()&#123; Session session = HibernateUtils.openSession(); session.beginTransaction(); User user =new User(); user.setId(2); session.delete(user); session.getTransaction().commit(); session.close(); &#125; 查 12345678910public void test_get()&#123; Session session = HibernateUtils.openSession(); session.beginTransaction(); User user =(User)session.get(User.class, 1); System.out.println(user); session.getTransaction().commit(); session.close(); &#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate系列-入门]]></title>
    <url>%2F2017%2F04%2F01%2Fhibernate-getstart%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你，如何使用Hibernate的映射文件 跟我学 项目结构 1234567--src/main/java----com.easy.a_basic------TestApp.java------User.java------hibernate.cfg.xml------User.hbm.xml----build.gradle build.gradle 123compile group: 'org.hibernate', name: 'hibernate-core', version: '5.1.0.Final' compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.38'compile group: 'junit', name: 'junit', version: '4.12' User.java 1234public class User &#123; private Integer id; private String username; private Integer age; User.hbm.xml 123456789101112&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.easy.a_basic.User" table="t_user"&gt; &lt;id name="id" column="ID"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="username" column="UserName"&gt;&lt;/property&gt; &lt;property name="age" column="Age"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; hibernate.cfg.xml 1234567891011121314151617&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;123456&lt;/property&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;mapping resource="com/easy/a_basic/User.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; TestApp.java 1234567891011121314151617181920212223public class TestApp &#123; public static void main(String[] args) &#123; //1.加载配置文件 URL url=TestApp.class.getResource("/com/easy/a_basic/hibernate.cfg.xml"); Configuration conf=new Configuration().configure(url); //2.创建工厂 SessionFactory sessionFactory = conf.buildSessionFactory(); //3.通过session建立与数据库的关系 Session session = sessionFactory.openSession(); //4.开启事务 Transaction trans=session.beginTransaction(); //5.业务逻辑 User user=new User(); user.setUsername("Kimsime"); user.setAge(18); session.save(user); //6.提交事务 trans.commit(); //7.关闭资源 session.close(); sessionFactory.close(); &#125;&#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识点回顾-国际化]]></title>
    <url>%2F2017%2F04%2F01%2Fjava-basic-international%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你，怎么使用国际化开发 控制台项目获取Locale的几种方式 123Locale locale=Locale.CHINA;Locale locale =new Locale("zh", "CN");System.out.println(Locale.getDefault()); 项目结构 12345--src/main/java----com.tutorial.resourcebundle------TestApp.java----res_en_US.properties----res_zh_CN.properties res_en_US.properties 123username=Usernamepassword=Passwordlogin=Login res_zh_CN.properties 123username=用户名password=密码login=登录 TestApp.java 123456Locale locale=Locale.US; //第一个参数：基本名称，第二个参数：Locale ResourceBundle rb=ResourceBundle.getBundle("res",locale);System.out.println(rb.getString("username")); System.out.println(rb.getString("password")); System.out.println(rb.getString("login")); Web项目 项目结构 123456--src/main/java--src/main/resources----res_en_US.properties----res_zh_CN.properties--src/main/webapp/views----login.jsp login.jsp 123456789101112131415&lt;body&gt; &lt;% //获取Locale，这是客户端的浏览器提供的Locale Locale locale =request.getLocale(); ResourceBundle rb = ResourceBundle.getBundle("res", locale); %&gt; &lt;h1&gt;&lt;%=rb.getString("login")%&gt;&lt;/h1&gt; $&#123;msg &#125; &lt;form action="$&#123;pageContext.request.contextPath &#125;/LoginServlet" method="post"&gt; &lt;%=rb.getString("username")%&gt;：&lt;input type="text" name="username" /&gt;&lt;br /&gt; &lt;%=rb.getString("password")%&gt;：&lt;input type="password" name="password" /&gt;&lt;br /&gt; &lt;input type="submit" value="&lt;%=rb.getString("login")%&gt;" /&gt; &lt;/form&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识点回顾-socket]]></title>
    <url>%2F2017%2F04%2F01%2Fjava-basic-socket%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你，如果使用Socket发送消息。 Socket常用方法获取InetAddress实例12345678910111213141516//获取本机的InetAddress实例 InetAddress address =InetAddress.getLocalHost(); System.out.println("计算机名："+address.getHostName()); System.out.println("IP地址："+address.getHostAddress()); byte[] bytes = address.getAddress();//获取字节数组形式的IP地址 System.out.println("字节数组形式的IP"+Arrays.toString(bytes)); System.out.println(address); //根据本机名获取InetAddress实例 InetAddress address2 = InetAddress.getByName("DeskTop"System.out.println("计算机名："+address2.getHostName()); System.out.println("IP地址："+address2.getHostAddress());//根据Ip地址获取InetAddress实例 InetAddress address3 = InetAddress.getByName("11.31.16.13System.out.println("计算机名："+address3.getHostName()); System.out.println("IP地址："+address3.getHostAddress()); 获取URL一些属性1234567891011URL imooc=new URL("http://www.baidu.com:80"); //#后面表示锚点 URL url=new URL(imooc,"/index.html?username=tom#test");System.out.println("协议号："+url.getProtocol()); System.out.println("主机："+url.getHost()); //如果未指定端口号，则使用默认的端口号，此时getPort()方法返回-1 System.out.println("端口："+url.getPort()); System.out.println("文件路径："+url.getPath()); System.out.println("文件名："+url.getFile()); System.out.println("相对路径："+url.getRef()); System.out.println("查询字符串："+url.getQuery()); 获取网页源代码12345678910111213141516171819public static void main(String[] args) throws Exception &#123; //创建一个URL实例 URL url =new URL("http://www.baidu.com"); //通过URL的openStream方法获取URL对象所表示的资源的字符输入流 InputStream in= url.openStream(); //将字节输入流转换为字符输入流 InputStreamReader isr=new InputStreamReader(in,"utf-8"); //为字符输入流添加缓冲 BufferedReader br=new BufferedReader(isr); String data = br.readLine();//读取数据 while(data!=null)&#123;//循环读取数据 System.out.println(data);//输出数据 data =br.readLine(); &#125; br.close(); isr.close(); in.close(); &#125; TCP通讯 项目结构 1234--src/main/java----Client.java----Server.java----ServerThread.java ServerThread.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ServerThread extends Thread&#123; //和本线程相关的Socket Socket socket=null; public ServerThread(Socket socket)&#123; this.socket=socket; &#125; @Override public void run() &#123; InputStream is=null; InputStreamReader isr=null; BufferedReader br=null; OutputStream os=null;; PrintWriter pw=null; try &#123; is=socket.getInputStream(); isr=new InputStreamReader(is,"utf-8"); br=new BufferedReader(isr); String info =null; while((info=br.readLine())!=null)&#123; System.out.println("我是服务器，客户端发来信息【"+info+"】"); &#125; //关闭输入流 socket.shutdownInput(); //向客户端返回信息 os = socket.getOutputStream(); pw = new PrintWriter(os); pw.write("欢迎你"); pw.flush();//将缓冲输出 &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; if(pw!=null) pw.close(); if(os!=null) os.close(); if(br!=null) br.close(); if(isr!=null) isr.close(); if(is!=null) is.close(); if(socket!=null) socket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; Server.java 12345678910111213141516171819public class Server &#123; public static void main(String[] args) throws Exception &#123; //1.创建一个服务器端的Socket，即ServerSocket ServerSocket serverSocket = new ServerSocket(8888); System.out.println("***服务器即将启动，等待客户端的连接***"); //2.调用accept()方法开始监听，等待客户端的连接 Socket socket = null; int count =0; while(true)&#123; socket =serverSocket.accept(); ServerThread serverThread=new ServerThread(socket); serverThread.start(); count++; System.out.println("客户端数量【"+count+"】"); InetAddress address=socket.getInetAddress(); System.out.println("当前客户端IP【"+address.getHostAddress()+"】"); &#125; &#125;&#125; Client.java 12345678910111213141516171819202122232425262728293031public class Client &#123; public static void main(String[] args) throws Exception &#123; //1.创建客户端Socket Socket socket =new Socket("localhost", 8888); //2.获取字节输出流，向服务器发送信息 OutputStream os=socket.getOutputStream(); //将输出流包装成打印流 PrintWriter pw=new PrintWriter(os); pw.write("用户名：admin；密码：123"); pw.flush(); //关闭输出流 socket.shutdownOutput(); InputStream is=socket.getInputStream(); InputStreamReader isr=new InputStreamReader(is); BufferedReader br=new BufferedReader(isr); String info =null; while((info=br.readLine())!=null)&#123; System.out.println(info); &#125; //3.关闭资源 br.close(); isr.close(); is.close(); pw.close(); os.close(); socket.close(); &#125;&#125; UDP通讯 项目结构 123--src/main/java----UDPClient.java----UDPServer.java UDPServer.java 1234567891011121314151617181920212223242526272829303132public class UDPServer &#123; public static void main(String[] args) throws IOException &#123; /** * 接收客户端发送的数据 */ //1.创建服务器端DatagramSocket DatagramSocket socket =new DatagramSocket(8800); System.out.println(socket.getLocalAddress().getHostAddress()); //2.创建数据报，用于接收客户端发送的数据 byte[] bytes=new byte[1024]; DatagramPacket packet = new DatagramPacket(bytes,bytes.length); //3.接收客户端发送的数据 System.out.println("****服务器端已经启动，等待客户端发送数据"); socket.receive(packet); //4.读取数据 String info =new String(bytes, 0, packet.getLength()); System.out.println("我是服务器，客户端说："+info); /** * 向客户端响应数据 */ //1.获取客户端的地址、端口、数据 InetAddress address =packet.getAddress(); int port=packet.getPort(); byte[] bytes2="欢迎你".getBytes(); //2.创建数据报，包含响应的数据信息 DatagramPacket packet2 =new DatagramPacket(bytes2, bytes2.length,address,port); //3.响应客户端 socket.send(packet2); //4.关闭资源 socket.close(); &#125;&#125; UDPClient.java 123456789101112131415161718192021222324252627282930public class UDPClient &#123; public static void main(String[] args) throws IOException &#123; /** * 向服务器发送数据 */ //1.定义服务器的地址、端口、数据 InetAddress address=InetAddress.getByName("localhost"); int port = 8800; byte[] data ="用户名=admin；密码=123".getBytes(); //2.创建数据报、包含发送的数据信息 DatagramPacket packet = new DatagramPacket(data, data.length,address,port); //3.创建DatagramSocket对象 DatagramSocket socket=new DatagramSocket(); //4.向服务器端发送数据报 socket.send(packet); /** * 接收服务器响应的数据 */ //1.创建数据报、用于接收服务器响应的数据 byte[] data2=new byte[1024]; DatagramPacket packet2 = new DatagramPacket(data2, data2.length); socket.receive(packet2); //2.接收服务器响应的数据 String reply = new String(data2, 0, packet2.getLength()); System.out.println("我是客户端，服务器说："+reply); //3.关闭资源 socket.close(); &#125;&#125;]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识点回顾-jdbc]]></title>
    <url>%2F2017%2F04%2F01%2Fjava-basic-jdbc%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你，如果使用源生的jdbc，以及连接池的使用。 使用源生的JDBC操作 sql脚本 123456create table t_user( id int not null primary key auto_increment, username char(50), password char(50)) 增删改 12345678910111213141516171819public void demo01() throws Exception&#123; String driverClassName="com.mysql.jdbc.Driver"; String url="jdbc:mysql://localhost:3306/test"; String username="root"; String password="123456"; Class.forName(driverClassName); Connection connection = DriverManager.getConnection(url,username,password); Statement statement = connection.createStatement(); String sql="insert into t_user(username,password) values('rose','123')"; int count =statement.executeUpdate(sql); System.out.println(count); System.out.println(connection); statement.close(); connection.close();&#125; 查询 1234567891011121314151617181920212223public void demo02() throws Exception&#123; String driverClassName="com.mysql.jdbc.Driver"; String url="jdbc:mysql://localhost:3306/test?useSSL=true"; String username="root"; String password="123456"; Class.forName(driverClassName); Connection connection = DriverManager.getConnection(url,username,password); Statement statement = connection.createStatement(); String sql="select * from t_user"; ResultSet resultSet = statement.executeQuery(sql); while(resultSet.next())&#123; int id=resultSet.getInt("id"); String name=resultSet.getString(2); System.out.println("id="+id+",name="+name); &#125; resultSet.close(); statement.close(); connection.close();&#125; 使用c3p0连接池 项目结构 123456--src/main/java----com.tutorial.jdbc.c3p0------JdbcUtils.java------TestApp.java------User.java----c3p0-config.xml build.gralde 123compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.38'compile group: 'c3p0', name: 'c3p0', version: '0.9.1.2'compile group: 'commons-dbutils', name: 'commons-dbutils', version: '1.6' c3p0-config.xml 1234567891011121314&lt;c3p0-config&gt; &lt;!-- 这是默认配置 --&gt; &lt;default-config&gt; &lt;!-- 连接四大参数配置 --&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/test&lt;/property&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;123456&lt;/property&gt; &lt;!-- 池参数配置 --&gt; &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; &lt;property name="minPoolSize"&gt;2&lt;/property&gt; &lt;property name="maxPoolSize"&gt;10&lt;/property&gt; &lt;/default-config&gt;&lt;/c3p0-config&gt; User.java 1234567891011public class User &#123; private int id; private String username; private String password; /** * javabean必须要有无参的构造函数 */ public User() &#123; super(); &#125; JdbcUtils.java 1234567891011public class JdbcUtils &#123; private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); public static Connection getConnection()throws SQLException&#123; return dataSource.getConnection(); &#125; public static DataSource getDataSource()&#123; return dataSource; &#125;&#125; TestApp.java 结果集转javabean 1234567public void test2JavaBean()throws Exception&#123; QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource()); String sql="select * from t_user where id=?"; Object[]params=&#123;3&#125;; User user=qr.query(sql, new BeanHandler&lt;User&gt;(User.class),params); System.out.println(user); &#125; 结果集转List 123456public void test2List()throws Exception&#123; QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource()); String sql="select * from t_user"; List&lt;User&gt;userList=qr.query(sql, new BeanListHandler&lt;User&gt;(User.class)); System.out.println(userList); &#125; 结果集转Map 1234567public void test2Map()throws Exception&#123; QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource()); String sql="select * from t_user where id=?"; Object[] params=&#123;1&#125;; Map&lt;String,Object&gt; map=qr.query(sql, new MapHandler(),params); System.out.println(map); &#125; 结果集转List 123456public void test2MapList()throws Exception&#123; QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource()); String sql="select * from t_user"; List&lt;Map&lt;String, Object&gt;&gt;mapList=qr.query(sql, new MapListHandler()); System.out.println(mapList); &#125; 获取单列结果集 1234567public void test2()throws Exception&#123; QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource()); String sql="select count(1) from t_user"; Number cnt=qr.query(sql, new ScalarHandler&lt;Number&gt;()); long c =cnt.longValue(); System.out.println(c); &#125;]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis系列-入门]]></title>
    <url>%2F2017%2F03%2F31%2Fmybatis-getstart%2F</url>
    <content type="text"><![CDATA[前言这是一个MyBatis的入门案例 跟我学 项目结构 123456789--src/main/java----com.easy.pojo------User.java------TestApp.java--src/main/resources----log4j.properties----SqlMapConfig.xml----User.xml--build.gradle build.gradle 12345678910111213apply plugin:'java'repositories&#123; maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;&#125;dependencies&#123; compile group: 'org.mybatis', name: 'mybatis', version: '3.4.1' compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.38' compile group: 'junit', name: 'junit', version: '4.12' &#125; User.java 1234567public class User &#123; private int id ; private String username; private String sex; private Date birthday; private String address;&#125; User.xml 123456789101112131415161718192021&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test"&gt; &lt;select id="findUserById" parameterType="int" resultType="com.easy.pojo.User"&gt; select * from User where id=#&#123;id&#125; &lt;/select&gt; &lt;select id="findUsersByName" parameterType="java.lang.String" resultType="com.easy.pojo.User"&gt; select * from user where username like '%$&#123;value&#125;%' &lt;/select&gt; &lt;select id="insertUser" parameterType="com.easy.pojo.User"&gt; insert into User(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/select&gt;&lt;/mapper&gt; SqlMapConfig.xml 1234567891011121314151617181920212223&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置mybatis的环境信息 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 配置JDBC事务控制，由mybatis进行管理 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源，采用dbcp连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=true" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="User.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; log4j.properties 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n TestApp.java findUserById() 123456789101112131415public void test_findUserById() throws Exception &#123; String resource="SqlMapConfig.xml"; InputStream is=Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession =sqlSessionFactory.openSession(); User user=sqlSession.selectOne("test.findUserById",27); System.out.println(user); sqlSession.close(); &#125; findUsersByName() 123456789101112131415public void test_findUsersByName() throws Exception &#123; String resource="SqlMapConfig.xml"; InputStream is=Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession =sqlSessionFactory.openSession(); List&lt;User&gt; list = sqlSession.selectList("test.findUsersByName","1"); System.out.println(list); sqlSession.close(); &#125; insertUser 123456789101112131415161718public void test_insertUser() throws Exception &#123; String resource="SqlMapConfig.xml"; InputStream is=Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession =sqlSessionFactory.openSession(); User user=new User(); user.setUsername("14"); user.setAddress("14"); sqlSession.insert("test.insertUser",user); sqlSession.commit(); sqlSession.close();&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-枚举]]></title>
    <url>%2F2017%2F03%2F31%2Fjava-basic-enum%2F</url>
    <content type="text"><![CDATA[前言本文介绍Java枚举的一些用法 跟我学几种不同类型的枚举 不带参数的枚举 123456enum Color&#123; RED,YELLOW,BLUE; private Color()&#123; &#125;&#125; 带参数的枚举 1234567enum Color&#123; RED(1),YELLOW(2),BLUE(3); //构造方法里面有参数，需要在每个实例上面都写参数 private Color(int i)&#123; &#125;&#125; 带抽象方法的枚举 1234567891011121314151617181920212223242526272829enum Color &#123; RED &#123; @Override public void say() &#123; // TODO Auto-generated method stub System.out.println("11"); &#125; &#125;,YELLOW &#123; @Override public void say() &#123; // TODO Auto-generated method stub &#125; &#125;,BLUE &#123; @Override public void say() &#123; // TODO Auto-generated method stub &#125; &#125;; //在枚举的每个实例里面都重写这个抽象方法 public abstract void say();&#125;public class Main03 &#123; public static void main(String[] args) &#123; Color red = Color.RED; red.say(); &#125;&#125; 枚举常用方法12345678910111213141516public class Main03 &#123; public static void main(String[] args) &#123; //知道枚举的对象，得到枚举名称和下标 System.out.println(Color.RED.name()); System.out.println(Color.RED.ordinal()); //知道枚举的名称，得到枚举的对象和下标 Color color = Color.valueOf("RED"); System.out.println(color); //知道枚举的下标，得到枚举的对象和名称 Color[] arr = Color.values();//得到枚举的对象 Color color2 = arr[0]; System.out.println(color2.name()); &#125;&#125;]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot系列-入门]]></title>
    <url>%2F2017%2F03%2F31%2Fspringboot-getstart%2F</url>
    <content type="text"><![CDATA[前言这是springboot的一个入门案例 简介为什么诞生了Spring Boot技术 spring 官方网站本身使用Spring 框架开发，随着功能以及业务逻辑的日益复杂，应用伴随着大量的XML配置文件以及复杂的Bean依赖关系。随着Spring 3.0的发布，Spring IO团队主键开始摆脱XML配置文件，并且在开发过程中大量使用“约定优先配置”（convention over configuration）的思想来摆脱Spring框架中各种复杂的配置，衍生了Java Config。Spring Boot正是在这样的一个背景下被抽象出来的开发框架，它本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序。也就是说，它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置（例如Jackson, JDBC, Mongo, Redis, Mail等等），Spring Boot应用中这些第三方库几乎可以零配置的开箱即用（out-of-the-box），大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。 项目结构注意启动类必须在最顶层，本次项目中的启动类是Program.java 123456--src/main/java----com.easy------Program.java----com.easy.controllers------HomeController.java--build.gradle 引入依赖环境12compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.4.2.RELEASE'compile group: 'org.springframework.boot', name: 'spring-boot-starter-test', version: '1.4.2.RELEASE' 编写启动类123456@SpringBootApplicationpublic class Program &#123; public static void main(String[] args) &#123; SpringApplication.run(Program.class, args); &#125;&#125; 编写控制层123456789101112@RestControllerpublic class HomeController &#123; /* * 访问http://localhost:8080/ * 访问http://localhost:8080 */ @RequestMapping public String hello() &#123; return "Hello Spring-Boot"; &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring系列-注入]]></title>
    <url>%2F2017%2F03%2F31%2Fspring-core-di%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你如何使用Spring DI 跟我学构造函数注入 项目结构 12345--src/main/java----com.easy.b_di.constructor------TestApp.java------User.java------beans.xml User.java 12345678910public class User &#123; private Integer uid; private String username; private Integer age; public User(String username, Integer age) &#123; this.username = username; this.age = age; &#125;&#125; beans.xml 123456789&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="userId" class="com.easy.b_di.constructor.User"&gt; &lt;constructor-arg index="0" type="java.lang.String" value="jack"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" type="java.lang.Integer" value="18"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; TestApp.java 12345678public class TestApp &#123; public static void main(String[] args) &#123; String xmlPath="com/easy/b_di/constructor/beans.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); User user = applicationContext.getBean("userId",User.class); System.out.println(user); &#125;&#125; Output 1User [uid=null, username=jack, age=18] 属性注入 项目结构 123456--src/main/java----com.easy.b_di.setter------Address.java------Person.java------TestApp.java------beans.xml Address.java 1234public class Address &#123; private String addr; private String tel;&#125; Person.java 123456public class Person &#123; private String name; private Integer age; private Address homeAddr; private Address companyAddr;&#125; beans.xml 12345678910111213141516171819202122232425&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="personId" class="com.easy.b_di.setter.Person"&gt; &lt;property name="name" value="jack"&gt;&lt;/property&gt; &lt;property name="age"&gt; &lt;value&gt;18&lt;/value&gt; &lt;/property&gt; &lt;property name="homeAddr" ref="homeAddrId"&gt;&lt;/property&gt; &lt;property name="companyAddr"&gt; &lt;ref bean="companyAddrId"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="homeAddrId" class="com.easy.b_di.setter.Address"&gt; &lt;property name="addr" value="温州"&gt;&lt;/property&gt; &lt;property name="tel" value="10086"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="companyAddrId" class="com.easy.b_di.setter.Address"&gt; &lt;property name="addr" value="杭州"&gt;&lt;/property&gt; &lt;property name="tel" value="100001"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; TestApp.java 12345678public class TestApp &#123; public static void main(String[] args) &#123; String xmlPath="com/easy/b_di/setter/beans.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); Person person = applicationContext.getBean("personId",Person.class); System.out.println(person); &#125;&#125; Output 1Person [name=jack, age=18, homeAddr=Address [addr=温州, tel=10086], companyAddr=Address [addr=杭州, tel=100001]]]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring系列-lifecycle]]></title>
    <url>%2F2017%2F03%2F31%2Fspring-core-lifecycle%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你如何使用Spring 声明周期 跟我学 项目结构 123456--src/main/java----com.easy.c_inject.b_static_factory------TestApp.java------UserService.java------UserServiceImpl.java------beans.xml UserService.java 123public interface UserService &#123; public void addUser();&#125; UserServiceImpl.java 123456789101112131415public class UserServiceImpl implements UserService &#123; @Override public void addUser() &#123; System.out.println(&quot;com.easy.e_lifecycle&quot;); &#125; public void myInit()&#123; System.out.println(&quot;初始化&quot;); &#125; public void myDestroy()&#123; System.out.println(&quot;销毁&quot;); &#125;&#125; beans.xml 1234567&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="userServiceId" class="com.easy.e_lifecycle.UserServiceImpl" init-method="myInit" destroy-method="myDestroy"&gt;&lt;/bean&gt;&lt;/beans&gt; TestApp.java 123456789public class TestApp&#123; public static void main(String[] args) &#123; String xmlPath="com/easy/e_lifecycle/beans.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); UserService userService = applicationContext.getBean("userServiceId",UserService.class); userService.addUser(); ((AbstractApplicationContext) applicationContext).close(); &#125;&#125; Output 123初始化com.easy.e_lifecycle销毁 总结Spring提供一种机制，只要实现接口BeanPostProcessor，并将实现类提供给Spring容器，Spring容器将自动执行，在初始化方法前执行before()，在初始化方法后执行after().]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring系列-scope]]></title>
    <url>%2F2017%2F03%2F31%2Fspring-core-scope%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你如何使用Spring Scope 跟我学 项目结构 123456--src/main/java----com.easy.c_inject.b_static_factory------TestApp.java------UserService.java------UserServiceImpl.java------beans.xml UserService.java 123public interface UserService &#123; public void addUser();&#125; UserServiceImpl.java 1234567public class UserServiceImpl implements UserService &#123; @Override public void addUser() &#123; System.out.println("com.easy.d_scope"); &#125;&#125; beans.xml 1234567&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="userServiceId1" class="com.easy.d_scope.UserServiceImpl"&gt;&lt;/bean&gt; &lt;bean id="userServiceId2" class="com.easy.d_scope.UserServiceImpl" scope="prototype"&gt;&lt;/bean&gt;&lt;/beans&gt; TestApp.java 1234567891011121314public class TestApp &#123; public static void main(String[] args) &#123; String xmlPath="com/easy/d_scope/beans.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); UserService userService11 = applicationContext.getBean("userServiceId1",UserService.class); UserService userService12 = applicationContext.getBean("userServiceId1",UserService.class); System.out.println(userService11==userService12); UserService userService21 = applicationContext.getBean("userServiceId2",UserService.class); UserService userService22 = applicationContext.getBean("userServiceId2",UserService.class); System.out.println(userService21==userService22); &#125;&#125; Output 12truefalse 总结Spring Container创建的对象，默认是单例的，是single.]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring系列-实例工厂]]></title>
    <url>%2F2017%2F03%2F29%2Fspring-core-non-static-factory-method%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你如何使用Spring 实例工厂 跟我学 项目结构 1234567--src/main/java----com.easy.c_inject.c_instance_factory------MyBeanFactory.java------TestFactory.java------UserService.java------UserServiceImpl.java------beans.xml UserService.java 123public interface UserService &#123; public void addUser();&#125; UserServiceImpl.java 1234567public class UserServiceImpl implements UserService &#123; @Override public void addUser() &#123; System.out.println("com.easy.c_inject.c_instance_factory"); &#125;&#125; MyBeanFactory.java 12345public class MyBeanFactory &#123; public UserService createService()&#123; return new UserServiceImpl(); &#125;&#125; beans.xml 12345678&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="myBeanFactory" class="com.easy.c_inject.c_instance_factory.MyBeanFactory"&gt;&lt;/bean&gt; &lt;bean id="userServiceId" factory-bean="myBeanFactory" factory-method="createService"&gt;&lt;/bean&gt;&lt;/beans&gt; TestApp.java 12345678public class TestFactory &#123; public static void main(String[] args) &#123; String xmlPath="com/easy/c_inject/c_instance_factory/beans.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); UserService userService = applicationContext.getBean("userServiceId",UserService.class); userService.addUser(); &#125;&#125; Output 1com.easy.c_inject.c_instance_factory 结论实例工厂方式，因为createXX方法不是静态的，就要先创建这个工厂实例，然后在通过调用这个实例的factory-method]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring系列-静态工厂]]></title>
    <url>%2F2017%2F03%2F29%2Fspring-core-static-factory-method%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你如何使用Spring 静态工厂 跟我学 项目结构 1234567--src/main/java----com.easy.c_inject.b_static_factory------MyBeanFactory.java------TestApp.java------UserService.java------UserServiceImpl.java------beans.xml UserService.java 123public interface UserService &#123; public void addUser();&#125; UserServiceImpl.java 1234567public class UserServiceImpl implements UserService &#123; @Override public void addUser() &#123; System.out.println("c_inject.b_static_factory"); &#125;&#125; MyBeanFactory.java 12345public class MyBeanFactory &#123; public static UserService createService()&#123; return new UserServiceImpl(); &#125;&#125; beans.xml 1234567&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="userServiceId" class="com.easy.c_inject.b_static_factory.MyBeanFactory" factory-method="createService"&gt;&lt;/bean&gt;&lt;/beans&gt; TestApp.java 12345678public class TestApp &#123; public static void main(String[] args) &#123; String xmlPath="com/easy/c_inject/b_static_factory/beans.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); UserService userService = applicationContext.getBean("userServiceId",UserService.class); userService.addUser(); &#125;&#125; Output 1c_inject.b_static_factory 总结静态工厂工厂方式，因为createXX方法是静态的，所以直接用factory-method就可以了]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring系列-IoC]]></title>
    <url>%2F2017%2F03%2F29%2Fspring-core-ioc%2F</url>
    <content type="text"><![CDATA[前言本文主要告诉你如何使用Spring Ioc 跟我学 项目结构 123456--src/main/java----com.easy.a_ioc------TestApp.java------UserService.java------UserServiceImpl.java------beans.xml UserService.java 123public interface UserService &#123; public void addUser();&#125; UserServiceImpl.java 1234567public class UserServiceImpl implements UserService &#123; @Override public void addUser() &#123; System.out.println("com.easy.a_ioc"); &#125;&#125; beans.xml 123456&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="userServiceId" class="com.easy.a_ioc.UserServiceImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; TestApp.java 12345678public class TestApp &#123; public static void main(String[] args) &#123; String xmlPath="com/easy/a_ioc/beans.xml"; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); UserService userService = applicationContext.getBean("userServiceId",UserService.class); userService.addUser(); &#125;&#125; Output 1com.easy.a_ioc 总结什么是IoC，字面意思是控制反转，即对某个东西的控制由专门的人来管理。举个实际例子：我要点外卖。我以前的操作：我找到一家外面店，然后点了外卖，然后吃我现在的操作：我下载了美团外卖，然后调用美团.我要点外卖()。即我把外卖的生命周期交给美团外卖来管理了。我不管这个外卖是那家点的，我只知道，美团外卖会帮我new()一个外卖出来。]]></content>
      <categories>
        <category>Spring-Core</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-deal-pwd-expired]]></title>
    <url>%2F2017%2F03%2F28%2Fdeal-mysql-password-expired%2F</url>
    <content type="text"><![CDATA[前言今天使用navicat连接mysql失败了 发现问题今天用navicat连接mysql的时候，报了一个错误 11862 - Your password has expired. To log in you must change it using a client that supports expired passwords. 分析问题原来mysql有个机制，就是90天必须要改一次密码，否则就会密码过期 解决问题 管理员打开dos 输入mysql -uroot -p，点击回车，会提示你输入旧密码 设置新密码：set password=password(&#39;123&#39;); 退出exit 再次登录，完美解决]]></content>
      <categories>
        <category>Deal-Problem</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery备忘录]]></title>
    <url>%2F2017%2F03%2F19%2Fcheat-sheet-jquery%2F</url>
    <content type="text"><![CDATA[前言这是jquery的常用操作 常用选择器1234567$('#div1') //id为div1的节点，如&lt;div id='div1'&gt;&lt;/div&gt; $('span') //所有的span结点，一个包装集$('p span') //p标签下的所有span节点，后代节点$('p&gt;span') //p标签下的所有span子节点，子代节点$('.red') //使用样式red的节点，如&lt;span class="red"&gt;&lt;/span&gt;$('*') //所有节点$("div,span,p.cls") //选取所有&lt;div&gt;，&lt;span&gt;和拥有class为cls的&lt;p&gt;标签的一组元素 基本筛选器123456789$('span:first') //第一个节点$('span:last') //最后一个节点$("td:even") //索引为偶数的节点，从 0 开始$("td:odd") //索引为奇数的节点，从 0 开始$("td:eq(1)") //给定索引值的节点$("td:gt(0)") //大于给定索引值的节点$("td:lt(2)") //小于给定索引值的节点$(":focus") //当前获取焦点的节点$(":animated") //正在执行动画效果的节点 内容选择器1234$("div:contains('hello')") //包含hello文本的节点$("td:empty") //不包含子节点或者文本的空节点$("div:has(p)") //含有选择器所匹配的节点$("td:parent") //含有子节点或者文本的节点 表单选择器1234567891011$("input:checked") //所有选中的节点$("select option:selected") //select中所有选中的option节点$(":input") //匹配所有 input, textarea, select 和 button 节点$(":text") //所有的单行文本框$(":password") //所有密码框$(":radio") //所有单选按钮$(":checkbox") //所有复选框$(":submit") //所有提交按钮$(":reset") //所有重置按钮$(":button") //所有button按钮$(":file") //所有文件域 筛选与查找12345678910111213141516171819202122$("p").eq(0) //当前操作中第N个jQuery对象,类似索引$('li').first() //第一个节点$('li').last() //最后一个节点$(this).hasClass("node") //节点是否含有某个特定的类,返回布尔值$('li').has('ul') //包含特定后代的节点$("div").children() //div中的每个子节点,第一层$("div").find("span") //查找div下的所有span节点$("p").next() //紧邻p节点后的一个同辈节点$("p").nextAll() //p节点之后所有的同辈节点$("#node").nextUntil("#node2") //id为"#node"节点之后到id为'#node2'之间所有的同辈节点,掐头去尾$("p").prev() //紧邻p节点前的一个同辈节点$("p").prevAll() //p节点之前所有的同辈节点$("#node").prevUntil("#node2") //id为"#node"节点之前到id为'#node2'之间所有的同辈节点,掐头去尾$("p").parent() //每个p节点的父节点$("p").parents() //每个p节点的所有祖先节点,body,html$("#node").parentsUntil("#node2") //id为"#node"节点到id为'#node2'之间所有的父级节点,掐头去尾$("div").siblings() //所有的同辈节点,不包括自己 属性操作1234567$("img").attr("src"); //返回文档中所有图像的src属性值$("img").attr("src","node.jpg"); //设置所有图像的src属性$("img").removeAttr("src"); //将文档中图像的src属性删除$("input[type='checkbox']").prop("checked", true); //选中复选框$("input[type='checkbox']").prop("checked", false); //不选中复选框$("img").removeProp("src"); //删除img的src属性 样式操作123$("p").addClass("selected"); //为p节点加上 'selected' 类$("p").removeClass("selected"); //从p节点中删除 'selected' 类$("p").toggleClass("selected"); //如果存在就删除,否则就添加HTML代码/文本/值 内容操作123456$('p').html(); //返回p节点的html内容$("p").html("Hello &lt;b&gt;hello&lt;/b&gt;!"); //设置p节点的html内容$('p').text(); //返回p节点的文本内容$("p").text("hello"); //设置p节点的文本内容$("input").val(); //获取文本框中的值$("input").val("hello"); //设置文本框中的内容 CSS操作123$("p").css("color"); //访问查看p节点的color属性$("p").css("color","red"); //设置p节点的color属性为red$("p").css(&#123; "color": "red", "background": "yellow" &#125;); //设置p节点的color为red，background属性为yellow（设置多个属性要用&#123;&#125;字典形式） 定位与偏移12345678$('p').offset() //节点在当前视口的相对偏移,对象 &#123;top: 5, left: 9&#125;$('p').offset().top$('p').offset().left$("p").position() //节点相对父节点的偏移,对可见节点有效，Object &#123;top: 5, left: 8&#125;$(window).scrollTop() //获取滚轮滑的高度$(window).scrollLeft() //获取滚轮滑的宽度$(window).scrollTop('25') //设置滚轮滑的高度为25 尺寸123456789$("p").height(); //获取p节点的高度$("p").width(); //获取p节点的宽度$("p:first").innerHeight() //获取第一个匹配节点内部区域高度(包括补白、不包括边框)$("p:first").innerWidth() //获取第一个匹配节点内部区域宽度(包括补白、不包括边框)$("p:first").outerHeight() //匹配节点外部高度(默认包括补白和边框)$("p:first").outerWidth() //匹配节点外部宽度(默认包括补白和边框)$("p:first").outerHeight(true) //为true时包括边距 DOM内部插入1234$("p").append("&lt;b&gt;hello&lt;/b&gt;"); //每个p节点内后面追加内容$("p").appendTo("div"); //p节点追加到div内后$("p").prepend("&lt;b&gt;Hello&lt;/b&gt;"); //每个p节点内前面追加内容$("p").prependTo("div"); //p节点追加到div内前 DOM外部插入1234$("p").after("&lt;b&gt;hello&lt;/b&gt;"); //每个p节点同级之后插入内容$("p").before("&lt;b&gt;hello&lt;/b&gt;"); //在每个p节点同级之前插入内容$("p").insertAfter("#node"); //所有p节点插入到id为node节点的后面$("p").insertBefore("#node"); //所有p节点插入到id为node节点的前面 DOM替换12$("p").replaceWith("&lt;b&gt;Paragraph. &lt;/b&gt;"); //将所有匹配的节点替换成指定的HTML或DOM节点$("&lt;b&gt;Paragraph. &lt;/b&gt;").replaceAll("p"); //用匹配的节点替换掉所有 selector匹配到的节点 DOM删除123$("p").empty(); //删除匹配的节点集合中所有的子节点，不包括本身$("p").remove(); //删除所有匹配的节点,包括本身$("p").detach(); //删除所有匹配的节点(和remove()不同的是:所有绑定的事件、附加的数据会保留下来) DOM复制12$("p").clone() //克隆节点并选中克隆的副本$("p").clone(true) //布尔值指事件处理函数是否会被复制 DOM加载完事件12345678$(document).ready(function()&#123; 您的代码...&#125;);//缩写$(function($) &#123; 您的代码...&#125;); 绑定事件1234567891011121314151617181920212223242526272829303132333435363738394041//bind 为每个匹配节点绑定事件处理函数，绑定多个用&#123;&#125;。$("p").bind("click", function()&#123; alert( $(this).text() );&#125;);$('#div1').bind(&#123; "mouseover":function () &#123; $('#div1').parent().removeClass("hide"); &#125;,"mouseout":function () &#123; $('#div1').parent().addClass("hide"); &#125;&#125;);$("p").one( "click", function()&#123;&#125;) //事件绑定后只会执行一次$("p").unbind( "click" ) //反绑一个事件//与bind 不同的是当时间发生时才去临时绑定。$("p").delegate("click",function()&#123; 您的代码&#125;);$("p").undelegate(); //p节点删除由 delegate() 方法添加的所有事件$("p").undelegate("click") //从p节点删除由 delegate() 方法添加的所有click事件$("p").click(); //单击事件$("p").dblclick(); //双击事件$("input[type=text]").focus() //节点获得焦点时,触发 focus 事件$("input[type=text]").blur() //节点失去焦点时,触发 blur事件$("button").mousedown()//当按下鼠标时触发事件$("button").mouseup() //节点上放松鼠标按钮时触发事件$("p").mousemove() //当鼠标指针在指定的节点中移动时触发事件$("p").mouseover() //当鼠标指针位于节点上方时触发事件$("p").mouseout() //当鼠标指针从节点上移开时触发事件$(window).keydown() //当键盘或按钮被按下时触发事件$(window).keypress() //当键盘或按钮被按下时触发事件,每输入一个字符都触发一次$("input").keyup() //当按钮被松开时触发事件$(window).scroll() //当用户滚动时触发事件$(window).resize() //当调整浏览器窗口的大小时触发事件$("input[type='text']").change() //当节点的值发生改变时触发事件$("input").select() //当input 节点中的文本被选择时触发事件$("form").submit() //当提交表单时触发事件$(window).unload() //用户离开页面时 事件对象12345678910111213$("p").click(function(event)&#123; alert(event.type); //"click" &#125;);(evnet object) 属性方法：event.pageX //事件发生时，鼠标距离网页左上角的水平距离event.pageY //事件发生时，鼠标距离网页左上角的垂直距离event.type //事件的类型event.which //按下了哪一个键event.data //在事件对象上绑定数据，然后传入事件处理函数event.target //事件针对的网页节点event.preventDefault() //阻止事件的默认行为(比如点击链接，会自动打开新页面)event.stopPropagation() //停止事件向上层节点冒泡 动态事件绑定1234//当p中增加span时仍然有效$("p").on("click",'span',function()&#123; alert( $(this).text() );&#125;); 动画效果12345678910111213$("p").show() //显示隐藏的匹配节点$("p").show("slow"); //参数表示速度,("slow","normal","fast"),也可为600毫秒$("p").hide() //隐藏显示的节点$("p").toggle(); //切换 显示/隐藏$("p").slideDown("600"); //用600毫秒时间将段落滑下$("p").slideUp("600"); //用600毫秒时间将段落滑上$("p").slideToggle("600"); //用600毫秒时间将段落滑上，滑下淡入淡出$("p").fadeIn("600"); //用600毫秒时间将段落淡入$("p").fadeOut("600"); //用600毫秒时间将段落淡出$("p").fadeToggle("600"); //用600毫秒时间将段落淡入,淡出$("p").fadeTo("slow", 0.6); //用600毫秒时间将段落的透明度调整到0.6 工具方法1234567891011121314$("#form1").serialize() //序列表表格内容为字符串。$("select, :radio").serializeArray(); //序列化表单元素为数组返回 JSON 数据结构数据$.trim() //去除字符串两端的空格$.each() //遍历一个数组或对象，for循环$.inArray() //返回一个值在数组中的索引位置，不存在返回-1 $.grep() //返回数组中符合某种标准的节点$.extend(&#123;a:1,b:2&#125;,&#123;b:3,c:4&#125;,&#123;c:5:d:6&#125;) //将多个对象，合并到第一个对象&#123;a:1,b:3,c:5,d:6&#125;$.makeArray() //将对象转化为数组$.type() //判断对象的类别（函数对象、日期对象、数组对象、正则对象等等$.isArray() //判断某个参数是否为数组$.isEmptyObject() //判断某个对象是否为空(不含有任何属性)$.isFunction() //判断某个参数是否为函数$.isPlainObject() //判断某个参数是否为用"&#123;&#125;"或"new Object"建立的对象$.support() //判断浏览器是否支持某个特性 AJAX使用ajax 123456789//保存数据到服务器，成功时显示信息$.ajax(&#123; type: "POST", url: "some.php", data: "name=John&amp;location=Boston", success: function(msg)&#123; alert( "Data Saved: " + msg ); &#125;&#125;); 使用load 12//加载 feeds.html 文件内容。$("#feeds").load("feeds.html"); 使用get 12//请求 test.php 网页，传送2个参数，忽略返回值。$.get("test.php", &#123; name: "John", time: "2pm" &#125; ); 使用post 12345//向页面 test.php 发送数据，并输出结果（HTML 或 XML，取决于所返回的内容）：$.post("test.php", &#123; name: "John", time: "2pm" &#125;,function(data)&#123; alert("Data Loaded: " + data);&#125;); 使用getJSON 12345678//从 Flickr JSONP API 载入 4 张最新的关于猫的图片。$.getJSON("http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&amp;tagmode=any&amp;format=json&amp;jsoncallback=?", function(data)&#123;$.each(data.items, function(i,item)&#123; $("&lt;img/&gt;").attr("src", item.media.m).appendTo("#images"); if ( i == 3 ) return false; &#125;);&#125;); 使用getScript 1234//加载并执行 test.js ，成功后显示信息$.getScript("test.js", function()&#123; alert("Script loaded and executed.");&#125;); ajax其他方法 123456789101112131415161718192021222324252627282930313233343536373839404142//AJAX 请求完成时执行函数。$("#msg").ajaxComplete(function(event,request, settings)&#123; $(this).append("&lt;li&gt;请求完成.&lt;/li&gt;");&#125;);//AJAX 请求失败时显示信息。$("#msg").ajaxError(function(event,request, settings)&#123; $(this).append("&lt;li&gt;出错页面:" + settings.url + "&lt;/li&gt;");&#125;);//AJAX 请求发送前显示信息。$("#msg").ajaxSend(function(evt, request, settings)&#123; $(this).append("&lt;li&gt;开始请求: " + settings.url + "&lt;/li&gt;");&#125;);//AJAX 请求开始时显示信息。$("#loading").ajaxStart(function()&#123; $(this).show();&#125;);//AJAX 请求结束后隐藏信息。$("#loading").ajaxStop(function()&#123; $(this).hide();&#125;);//当 AJAX 请求成功后显示消息。$("#msg").ajaxSuccess(function(evt, request, settings)&#123; $(this).append("&lt;li&gt;请求成功!&lt;/li&gt;");&#125;);//请求前过滤$.ajaxPrefilter( function( options, originalOptions, jqXHR ) &#123; // Modify options, control originalOptions, store jqXHR, etc &#125;);//设置全局 AJAX 默认选项，设置 AJAX 请求默认地址为 "/xmlhttp/"，禁止触发全局 AJAX 事件，用 POST 代替默认 GET 方法。其后的 AJAX 请求不再设置任何选项参数。$.ajaxSetup(&#123; url: "/xmlhttp/", global: false, type: "POST"&#125;);$.ajax(&#123; data: myData &#125;); 参考文章http://www.cnblogs.com/best/p/5748515.html]]></content>
      <categories>
        <category>Cheat-Sheet</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse常用快捷键]]></title>
    <url>%2F2017%2F03%2F15%2Fcheat-sheet-eclipse-shortcut-key%2F</url>
    <content type="text"><![CDATA[前言记录工作中经常用到的一些快捷键 快捷键123456789101112131415161718192021222324252627282930313233Ctrl+D：删除当前行Ctrl+Shift+Enter：快速创建行Ctrl+Shift+T：找类文件Ctrl+Shift+R：找资源文件Ctrl+Shift+X：转大写Ctrl+Shift+Y：转小写Ctrl+Shift+G：查找调用某个方法的类Ctrl+Shift+P：根据左大括号找到右大括号Ctrl+H：在文件中查找Ctrl+T：查看类型的继承链Ctrl+O：查看类型的成员Alt+Shift+S+S：toString()Alt+Shift+S+R：Generate Getters and SttersAlt+Shift+S+H：HashCode()Alt+Shift+A：矩阵编辑Alt+Shift+N：创建各种类型的文件Alt+Shift+右方向键：选中根据左大括号到右大括号的/**+Enter：方法快速注释Alt+/：代码提示Ctrl+E：显示当前打开的文件Ctrl+F11：运行java项目Ctrl+W：关闭当前文件Alt+ ←：恢复当前关闭的文件Ctrl+Shift+W：关闭所有文件Ctrl+F：在文本中搜索Esc：关闭当前打开的视图Ctrl+Alt+上方向键/下方向键：复制当前行，或选中的代码块Alt+Shift+W：文件在项目中的位置（或选中Link with Editor）]]></content>
      <categories>
        <category>Cheat-Sheet</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM初探-常量]]></title>
    <url>%2F2017%2F03%2F14%2Flearn-jvm-bytecode-variate%2F</url>
    <content type="text"><![CDATA[前言这段时间一直在看JVM相关的书籍，虽然有点难，至少到目前为止还没有放弃。写这篇文章的目的：当做自己这段时间学习的小回顾。本问主要通过几个代码片段，分析下局部变量表与操作数栈之间的数据传递关系，重点讲解iload,istore,iconst_&lt;n&gt;,iadd命令 提前了解JVM的几个概念 局部变量表：每个栈帧内部都包含一组称为局部变量表的变量列表 操作数栈：每个栈帧内部都包含一个操作数栈 iconst_0：把int型的0值压入操作数栈 iload：将一个局部变量加载到操作数栈上 istore：将一个数值从操作数栈上存储到局部变量表中 iadd：返回栈顶的两个元素做加法运算，并加结果压栈 如何使用dos查看字节码文件首先通过dos进入TestApp.class所在的目录，然后运行命令javap -c TestApp，即可看到编译后的字节码文件 程序片段一 以下是一个java源代码 123public void test1()&#123; int c=0; &#125; 编译后的字节码 12345public void test1(); Code: 0: iconst_0 1: istore_1 2: return 代码分析 因为test1()是一个实例方法，所以在局部变量表中，索引为0的位置会保存该方法所在类的引用(this)，所以才会出现istore_1而不是istore_0。 我们对int c = 0做下拆解，一个常量0，一个变量c。 1230: iconst_0 //将常量0压入操作数栈1: istore_1 //将栈顶出栈，即c=02: return //因为是void，没有返回值 程序片段二 Java源代码如下 123public static void test2()&#123; int c=0; &#125; 编译后的字节码文件 12345public static void test2(); Code: 0: iconst_0 1: istore_0 2: return 分析 因为test2()是一个静态的方法，不会在局部变量表中插入任何数据。所以你看到的是istore_0而不是像程序片段一中的istore_1。其他分析跟程序片段一相同 程序片段三 java源代码 1234public int test3()&#123; int c=0; return c; &#125; 编译后的字节码 123456public int test3(); Code: 0: iconst_0 1: istore_1 2: iload_1 3: ireturn 分析 12340: iconst_0 //将常量0压栈1: istore_1 //将栈顶出栈，及c=02: iload_1 //将变量c压入栈顶3: ireturn //返回栈定元素 程序片段四 Java源代码 1234public int test4(int a,int b)&#123; int c=0; return a+b; &#125; 编译后的字节码 12345678public int test4(int, int); Code: 0: iconst_0 1: istore_3 2: iload_1 3: iload_2 4: iadd 5: ireturn ** 分析 因为test4(int a,int b)是实例方法，所以在局部变量表索引为0的位置会插入this。因为test4(int a,int b)带有两个参数，所以在局部变量索引索引为1的位置插入a，在索引为2的位置插入b。 1234560: iconst_0 //将常量0压栈1: istore_3 //将栈顶出栈，即c=0，将c存储到局部变量表索引为3的位置2: iload_1 //将局部变量表中索引为1的变量压栈，即a压栈3: iload_2 //将局部变量表中索引为2的变量压栈，即b压栈4: iadd //将栈顶两个元素出栈，做加法，然后把结果再入栈(即a,b出栈，将a+b入栈)5: ireturn //返回a+b的值 程序片段五 java源代码 12345public int test5(int a,int b)&#123; int c=0; c= a+b; return c; &#125; 编译后的字节码 12345678910public int test5(int, int); Code: 0: iconst_0 1: istore_3 2: iload_1 3: iload_2 4: iadd 5: istore_3 6: iload_3 7: ireturn 分析 123456780: iconst_0 //将常量0压栈1: istore_3 //将栈顶出栈，及c=02: iload_1 //从局部变量表中加载索引为1的变量压栈，即a压栈3: iload_2 //从局部变量表中加载索引为2的变量压栈，即b压栈4: iadd //将栈顶两个元素出栈，做加法，然后将结果压栈，及a+b压栈5: istore_3 //将栈顶元素出栈,并保存到局部变量表中，即c=a+b6: iload_3 //从局部变量表中加载索引为3的变量压栈，即c压栈7: ireturn //返回栈顶元素，即返回c]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java总结-IO]]></title>
    <url>%2F2017%2F03%2F13%2Fjava-basic-io%2F</url>
    <content type="text"><![CDATA[前言为什么IO包下有这么多类，存在即合理，带你一步步剖析。 为什么需要IO操作我们浏览网页，看到有用信息，通过收藏网页方式记录下来。我们看书，看到有感触的句子，会用本子摘录下来。我们看公众号，看到好玩的内容，就分享到朋友圈。上面三个例子，在对信息处理上有个共同点，那就是获取与记录，也即是输入与输出。 输入有多种渠道，可以是网页，公众号，书籍。 输出也有多种方式，可以是收藏，手抄，分享。 在Java中，把这部分进行了抽象，对数据的获取过程称为输入流，对数据的记录称为输出流。 对于输入的多种渠道，分别定义了多个具体的类。 对于输出的多种方式，也定义了多个具体的类。 如果我们想自己定义一种输入方式，java自己本身提供了大量的装饰类，当然你也可以使用装饰者模式定义自己的装饰类。比如：对于手抄，你是理解了一句话，再抄；还是看一个字抄一下。 IO体系架构所有数据都可以转化成字节，而计算机也只能识别字节，所以Java提供了字节流。 因为我们写的文本都是字符方式存储的，方便人的读取，Java提供了字符流。 有时候我们仅仅只是想创建一个文件，或目录，并没有涉及到输入和输出，Java也提供了操作文件与目录的File类。 当我们想随机读取流中的任意部分时，就可以用RandomAccessFile。 还有一些其他类：文件读取部分的与安全相关的类，如：SerializablePermission类；以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类 IO派系IO的各成员就如一个个派系一样，每一个派系都有自己的小团队。 InputStreamInputStream是所有输入流的父类，它定义了输入流的一些公共方法。 int read()：一次读一个字节 int read(byte b[])：读取b.length长度的字节到b数组 int read(byte b[], int off, int len)：读取指定位置字节到b数组 long skip(long n)：忽略输入流中的n个字节 int available()：返回输入流中可以读取的字节数 void close()：关闭流 FileInputStreamFileInputStream继承与InputStream ByteArrayInputStreamByteArrayInputStream继承与InputStream OutputStreamOutputStream是所有输出流的父类，定义了所有输出流公共的方法。 void write(int b)：往输出流中写入一个特定的字节 write(byte b[])：往输出流中写入一个字节数组 write(byte b[], int off, int len)：往输出流中写入指定位置的字节数组 void flush()：将数据缓存去中数据全部输出，并清空缓冲区 void close()：关闭输出流 FileOutputStream ByteArrayOutputStream ReaderReader是所有字符输入流的父类，定义了一些公共方法 int read()：读取一个字符 read(char cbuf[]):读取cbuf.length长度的字符到cbuf数组中 int read(char cbuf[], int off, int len)：读取指定位置字节到cbuf数组 long skip(long n)：忽略n个字符 boolean ready()：是否可以读 void close()：关闭流 InputStreamReader Writer write和append的作用是一样的，不过append()返回的是Writer本身，可以写链式编程 OutputStreamWriter 如何选择IO流 确定是输入还是输出 输入:输入流 InputStream Reader 输出:输出流 OutputStream Writer 明确操作的数据对象是否是纯文本 是:字符流 Reader，Writer 否:字节流 InputStream，OutputStream 明确具体的设备。 文件： 读：FileInputStream,, FileReader, 写：FileOutputStream，FileWriter 数组： byte[ ]：ByteArrayInputStream, ByteArrayOutputStream char[ ]：CharArrayReader, CharArrayWriter String： StringBufferInputStream(已过时，因为其只能用于String的每个字符都是8位的字符串), StringReader, StringWriter Socket流 键盘：用System.in（是一个InputStream对象）读取，用System.out（是一个OutoutStream对象）打印 是否需要转换流 是，就使用转换流，从Stream转化为Reader、Writer：InputStreamReader，OutputStreamWriter 是否需要缓冲提高效率 是就加上Buffered：BufferedInputStream, BufferedOuputStream, BufferedReader, BufferedWriter 是否需要格式化输出 一些案例删除非空文件夹12345678910111213private static boolean deleteDir(File dir)&#123; if(dir.isDirectory())&#123; String[] childrenFiles=dir.list(); for(int i=0;i&lt;childrenFiles.length;i++)&#123; File childFile =new File(dir,childrenFiles[i]); boolean success = deleteDir(childFile); if(!success)&#123; return false; &#125; &#125; &#125; return dir.delete(); &#125; Main 123456public static void main(String[] args) &#123; File folder =new File("D:\\CodeLocation\\GitLocation"); System.out.println(folder.isDirectory()); boolean result = deleteDir(folder); System.out.println(result); &#125; InputStream和OutputStream InputStream 12345678910111213//从File中获取输入流，也可以直接使用InputStream is = new FileInputStream("src/main/java/love.txt") File file = new File("src/main/java/love.txt"); InputStream is = new FileInputStream(file); //将输入流一次性全部写进缓冲区 byte[] buffer=new byte[1024]; int len = is.read(buffer); //将byte数组转换成字符串 String inputString = new String(buffer,0,len,"utf-8"); System.out.println(inputString); is.close(); OutputStream 123456789101112//在项目的根目录下有个文件叫love.txt， //也可以直接使用OutputStream os=new FileOutputStream("src/main/java/love2.txt"); File file = new File("src/main/java/love2.txt"); OutputStream os=new FileOutputStream(file); //将文本转换成byte数组 String outString ="我爱你"; byte[] buffer =outString.getBytes("utf-8"); //往输出流中写入byte数组 os.write(buffer); os.close(); FileReader和FileWriter FileReader 12345678910111213//从File中获取输入流 File file = new File("src/main/java/love.txt"); Reader reader = new FileReader(file); //将输入流一次性写进缓冲区 char[] chars =new char[100]; int len = reader.read(chars); //将字符数组转换成字符串 String inputString =new String(chars, 0, len); System.out.println(inputString); reader.close(); FileWriter 123456789101112//从file中获取输出流,第二个参数表示是否追加 File file = new File("src/main/java/love3.txt"); Writer writer =new FileWriter(file,true); //将对象写入缓存区 String outString = "我爱你"; writer.write(outString); //刷新，将字符写进目的地 writer.flush(); writer.close(); BufferedReader和BufferedWriter BufferedReader 12345678910111213141516//创建文件的输入流 File file = new File("src/main/java/love.txt"); InputStream is = new FileInputStream(file); //创建输入流的Reader InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); String line; while((line=br.readLine())!=null)&#123; System.out.println(line); &#125; br.close(); isr.close(); is.close(); BufferedWriter 123456789101112131415//创建文件的输出流 File file = new File("src/main/java/love4.txt"); OutputStream os=new FileOutputStream(file); //创建输出流的Reader OutputStreamWriter osw=new OutputStreamWriter(os,"utf-8"); BufferedWriter bw=new BufferedWriter(osw); //向Reader中写数据 bw.write("我爱Python"+"\n"); bw.write("我爱.Net"); bw.close(); osw.close(); os.close(); ByteArrayInputStream和ByteArrayOutputStream12345678910111213URL url=new URL("http://kimisme.com"); InputStream is = url.openStream(); ByteArrayOutputStream baos=new ByteArrayOutputStream(); int c= is.read(); while(c!=-1)&#123; baos.write(c); c=is.read(); &#125; is.close(); byte[] arr = baos.toByteArray(); String outputString = new String(arr); System.out.println(outputString); 参考文章http://linbingdong.com/2017/01/11/Java%20I:O%E6%80%BB%E7%BB%93/]]></content>
      <categories>
        <category>Java-Basic</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 备忘录]]></title>
    <url>%2F2017%2F03%2F11%2Fcheat-sheet-mysql%2F</url>
    <content type="text"><![CDATA[前言工作中，参与一个重构的项目，使用的是mysql。这篇文章就记录mysql的一些常用操作，持续更新中。 走进MySqlMySql服务配置环境变量 1在Path中添加C:\Program Files\MySQL\MySQL Server 5.7\bin 启动服务 1net start mysql; 登录Mysql 123mysql -h 地址 -P 端口 -u 用户名 -p;mysql -h 127.0.0.1 -P 3306 -u root -p;mysql -h 127.0.0.1 -u root -p; 登录到指定数据库 1mysql -D test -h 127.0.0.1 -u root -p; 查看mysql信息 123456789101112131415161718mysql&gt; status;--------------mysql Ver 14.14 Distrib 5.7.10, for Win64 (x86_64)Connection id: 15Current database: testCurrent user: root@localhostSSL: Not in useUsing delimiter: ;Server version: 5.7.10-log MySQL Community Server (GPL)Protocol version: 10Connection: 127.0.0.1 via TCP/IPServer characterset: utf8Db characterset: utf8Client characterset: utf8Conn. characterset: utf8TCP port: 3306Uptime: 28 min 51 sec 查看mysql版本 123456mysql&gt; select version();+------------+| version() |+------------+| 5.7.10-log |+------------+ 查看mysql端口 123456mysql&gt; show global variables like 'port';+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3306 |+---------------+-------+ 数据库操作查看当前数据库 1select databases(); 创建数据库 123create database [if not exists] 数据库名 数据库选项create database samp_db character set utf8;；create database if not exists samp_db character set utf8; 查看已有库 12show databases [like 'pattern']show databases like 'sa%'; 查看当前库信息 12show create database 数据库名show create database samp_db; 修改库的选项信息 12alter database 库名 选项信息alter database samp_db character set utf8; 删除库 123456789101112drop database [if exists] 数据库名drop database samp_db;drop database if exists samp_db;``` ## 表操作### 创建表``` sqlcreate [temporaty] table [if not exists] [库名].表名(表的结构定义)[表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 temporary临时表，回话结束时表自动消失 字段的定义：字段名 数据类型 [not null][null][default default_value][auto_increment][unique[key]|[primary]key][comment ‘string’] 123456789create table user_accounts(id int(100) unsigned not null auto_increment primary key,username varchar(32) not null default '' comment '用户姓名',password varchar(32) not null default 'abc123' comment '用户密码',mobile varchar(32) not null default '' comment '手机',unique index idx_user_mobile(mobile))engine=InnodB default charset=utf8comment='用户信息表'; 数据类型说明 数据类型 说明 null 可空 not null 不可为空 default 默认值 primary key 主键 auto_increment 自增长 unsigned 数据类型只能为正数 character set name 指定过一个字符集编码 comment 字段说明 修改表修改表本身的选项 12alter table 表名 表的选项alter table test engine = MYISAM 表重命名 123rename table 原表名 to 库名.新表名rename table test to test_newrename table test to samp_db.test_new 删除表 123drop table [if exists] 表名drop table user_accounts;drop table if exists user_accounts; 清空表数据 1truncate [table] 表名 复制表结构 12create table 表名 like 要复制的表名create table user_accounts_copy like user_accounts; 复制表结构和数据 123create table 表名 [as] select * from 要复制的表名create table user_accounts_copy as select * from user_accounts;create table user_accounts_copy select * from user_accounts; 检查表是否有错误 12create table tbl_name,[tbl_name2]check table user_accounts,user_info; 优化表 12optimize [local|no_write_to_binlog] table tbl_name,[tbl_name2] optimize local table user_accounts; 修复表 12repair [local|no_write_to_binlog] table tbl_name,[tbl_name2] [quick] [extended] [use_frm]repair local table user_accounts; 分析表 12analyze [local|no_write_to_binlog] table tbl_name,[tbl_name2] [quick] [extended] [use_frm]analyze table user_accounts; 数据操作增 123456insert [into] 表名 [(字段列表)] values(值列表)--如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表insert into user_accounts(username) values(2);--可同时插入多条数据记录insert into user_accounts(username,mobile) values (5,5),(6,6) 删 12delete from 表名 [删除条件子句]delete from user_accounts; 改 12update 表名 set 字段名 = 新值 [,字段名 = 新值] [条件子句]update user_accounts set password = '123'; 查 12select 字段列表 from 表名 [其他子句]select username from user_accounts where length(mobile)!=11; 列操作添加字段 1234alter table 表名 操作名 add [column] 字段名alter table t_user add hobby char(60);alter table t_user add birthday date after username;alter table t_user add age int not null default '18' after password; 创建主键 1alter table 表名 add primary key(字段名) 创建唯一索引 1alter table 表名 add unique [索引名](字段名) 创建普通索引 12alter table 表名 add index [索引名](字段名)alter table t_metercard add index MeterID(MeterID); 删除字段 1alter table 表名 drop [column] 字段名 修改字段属性 1alter table 表名 modify [column] 字段名 字段属性 修改字段名 1alter table 表名 change [column] 原字段名 新字段名 字段属性 删除主键 1alter table 表名 drop primary key 删除索引 1alter table 表名 drop index 索引名 删除外键 1alter table 表名 drop foreign key 外键 函数数值函数1234567891011select abs(-3.14);--绝对值，3.14select format(3.14,1);--格式化小数，3.1select ceil(3.14);--向上取整，4select floor(3.6);--向下取整，3select round(3.14);--四舍五入取整，3select mod(10,3);--取余，1select pi();--圆周率select pow(2,3);--2的3次方，8select sqrt(16);--算法平方根，4select rand();--0到1之间的随机数select truncate(3.1415,3);--截取3位小数 时间日期函数123456789select now();--获取当前时间，2017-03-19 16:30:16select current_timestamp();--获取当前时间，2017-03-19 16:30:50select current_date();--获取当前日期，2017-03-19select current_time();--获取当前时间，16:31:33select date(now());--获取日期部分，2017-03-19select time(now());--获取时间部分，16:34:53select date_format(now(),'%Y/%m/%d');--格式化时间，2017/03/19select unix_timestamp();--获取unix时间戳，1489912619select from_unixtime(1489912619);--时间戳转时间，2017-03-19 16:36:59 字符串函数12345678910111213141516171819select length('杭州');--几个字节长度，6select char_length('杭州');--几个字符个数，2select substring('abcdef',1,2);--字符串截取，abselect replace('abcabc','ab','AB');--字符串替换，ABcABcselect instr('abcabc','b');--字符第一次出现索引位置，2select locate('b','abcabc',3);--字符串从3开始出现索引位置，5select concat('aa','bb','cc');--字符串连接，aabbccselect charset('abc');--字符字符集，utf8select lcase('ABC');--转换成小写，abcselect ucase('abc');--转换成大写，ABCselect left('abcdef',2);--从左边起取字符，abselect right('abcdefe',2);--从右边起取字符，feselect lpad('abc',8,'0');--从左开始填充，00000abcselect rpad('abc',8,'0');--从右开始填充，abc00000--select load_file('D:\aa.txt');--读文件，要权限select ltrim(' abc');--去左空格select rtrim('abc ');--去右空格select repeat('abc',2);--字符串重复，abcabcselect strcmp('abc','abd');--字符串比较大小 流程函数12345select case when username='1' then '用户1'when username='2' then '用户2'else '用户3' endfrom user_accounts; 聚合函数12345select count(1) from user;select sum(age) from user;select max(age) from user;select min(age) from user;select avg(age) from user; 其他函数1select count(1) from user; 日期与时间12--时间格式化select date_format(now(),'%Y-%m-%d'); 常用sql语句变量赋值mysql中变量在使用前不用事先声明，在用的时候，直接@变量名就可以了 12345678-- 方式一：select @num:=count(1) from t_company;-- 方式二：set @num = 314;select @num;-- 方式三：set @num := 1;select @num; 统计各表记录数12345use information_schema;select table_name,table_rows from tables where TABLE_SCHEMA = 'db-to-mid' order by table_rows desc; 给用户授权grant all on gs_xt.* to 'root'@'%' identified by '123456' with grant option; 参考文章https://segmentfault.com/a/1190000006876419https://juejin.im/post/584e7b298d6d81005456eb53http://www.cnblogs.com/best/p/6517755.html#_label3_4_4_6]]></content>
      <categories>
        <category>Cheat-Sheet</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlserver备忘录]]></title>
    <url>%2F2017%2F03%2F10%2Fcheat-sheet-sqlserver%2F</url>
    <content type="text"><![CDATA[前言这套笔记是大学的时候写的，最初是发布在博客园，现在是把重新整理到这个博客。 数据的过滤说明如果使用了where 1=1 的过滤条件以后数据库系统就无法使用检索等查询优化策略了，数据库系统会被迫对每行数据进行扫描，即全表扫描。 简单过滤 检索指定列 1select name from t_user; 给列设别名 12select name as '姓名' from t_user;select name 姓名 from t_user; 按条件过滤 1select * from t_user where id &lt;3; 数据汇总 12345select max(age) from t_user;select min(age) from t_user;select avg(age) from t_user;select sum(age) from t_user;select count(*) from t_user; 排序 12select * from t_user order by age desc;select * from t_user order by age desc,id ase; 正则过滤 说明 1使用通配符过滤虽然方便，但是会对数据库全部扫描，执行速度慢 单字符匹配 1select * from t_user where name like '_love'; 多字符匹配 1select * from t_user where name like 'love%'; 集合匹配 1select * from t_user where name like '[张李王]_'; 否定匹配 1select * from t_user where name like '[^张李]%'; 空值检测12select * from t_user where name is null;select * from t_user where name = ''; 不等运算12select * from t_user where age !=18;select * from t_user where age &lt;&gt;18; 多值检测1select * from t_user where name like '金_' and gener = '男'; 范围检测123select * from t_user where age = 18 or age =19 or age =20;select * from t_user where age in (18,19,20);select * from t_user where age between 18 and 20; 索引 创建表 1234567create table T_User( Id int primary key identity(1,1), UNo nvarchar(10), UName nvarchar(10), UAge int) 创建索引 1create index idx_user_name on T_User(UName) 删除索引 1drop index idx_user_name on T_User 字符串处理 字符串的长度 1select len('Kimisme') 大小写转换 12select lower('JACK');select upper('rose'); 字符串去空格 123select ltrim(' love');select rtrim('love ');select ltrim(rtrim(' love ')); 字符串截取 123select left('abcdefg',3);--abcselect right('abcdefg',3);--efgselect substring('abcdefg',3,2);--cd 字符串替换 1select replace('Hello,World','World','Python'); 字符串转义 12select ascii('a');--97select char(97);--a 字符串出现位置 1select charindex('m','kimisme');--3 反转字符串 1select reverse('abc');--cba 数学函数 绝对值 1select abs(-3.14); 随机数 12select rand();--0-1之间select rand(2);--只产生一次，继续运行不变 四舍五入 123select round(1.5555,2);--四舍五入：1.5600select ceiling(1.1);--舍入到最大整数：2select floor(1.9);--舍入到最小整数：1 三角函数 12345678select sin(1);--正弦select cos(1);--余弦select tan(1);--正切select asin(1);--反正弦select acos(1);--反余弦select atan(1);--反正切select tan2(1,1),atan(1);--反正切select cat(1);--余切 圆周率 1select pi(); 角度制与弧度制 12select degrees(1),1*180/pi();--弧度制转角度制：角度制=弧度制*100/πselect radians(1),1*pi()/180;--角度制转弧度制：弧度制=角度制*π/180 求一个数的符号 1select sign(-3.14),sign(3.14);大于0返回1；小于0返回-1 两个数相除 12select 7/3;--2select 7%3;--1 指数与平方根 12select power(2,3);--8select sqrt(16);--4 日期与时间的操作获取当前时间1select getdate();--2015-08-11 20:25:30.973 以指定格式显示日期12345678910111213141516select convert(varchar(50),getdate(),101) --08/11/2015select convert(varchar(50),getdate(),102) --2015.08.11select convert(varchar(50),getdate(),103) --11/08/2015select convert(varchar(50),getdate(),104) --11.08.2015select convert(varchar(50),getdate(),105) --11-08-2015select convert(varchar(50),getdate(),106) --11 08 2015select convert(varchar(50),getdate(),107) --08 11, 2015select convert(varchar(50),getdate(),108) --20:26:11select convert(varchar(50),getdate(),109) --08 11 2015 10:53:15:397PMselect convert(varchar(50),getdate(),110) --08-11-2015select convert(varchar(50),getdate(),111) --2015/08/11select convert(varchar(50),getdate(),112) --20150811select convert(varchar(50),getdate(),113) --11 08 2015 22:52:17:143select convert(varchar(50),getdate(),114) --22:53:45:847select convert(varchar(50),getdate(),120) --2015-08-11 22:45:34select replace(replace(replace(CONVERT(varchar, getdate(), 120 ),'-',''),' ',''),':','') --20150811225416 日期差额12345678select dateadd(year,3,'2015-08-11 20:25:30.973') --2018-08-11 20:25:30.973 --年select dateadd(quarter,1,'2015-08-11 20:25:30.973') --2015-11-11 20:25:30.973--季度select dateadd(month,3,'2015-08-11 20:25:30.973') --2015-11-11 20:25:30.973--月份select dateadd(day,3,'2015-08-11 20:25:30.973') --2015-08-14 20:25:30.973 -- 日select dateadd(hour,3,'2015-08-11 20:25:30.973') --2015-08-11 23:25:30.973 -- 小时select dateadd(minute,3,'2015-08-11 20:25:30.973') --2015-08-11 20:28:30.973 --分select dateadd(second,3,'2015-08-11 20:25:30.973') --2015-08-11 20:25:33.973 --秒select dateadd(millisecond,3,'2015-08-11 20:25:30.973') --2015-08-11 20:25:30.977 --毫秒 计算两个日期相差几天1select datediff(day,'2015-08-11','2015-08-14') -- 3 计算一个日期是星期几1select datename(weekday,'2015-08-11') --星期二 获取日期的指定部分123select datepart(year,'2015-08-11') – 2015select datepart(month,'2015-08-11') – 8select datepart(day,'2015-08-11') – 11 动态执行sql语句1234567891011declare @busshallID nvarchar(255)='2,3'declare @strWhere nvarchar(255)=''declare @strMain nvarchar(255)if(@bussHallId is not null) set @strWhere = @strWhere + ' and bh.ID in ('+@bussHallId+')' set @strMain = ' select bh.Name as ''名称'',bh.CreateTime from T_BussHall bhwhere 1 =1 ' +@strWhereexec(@strMain)]]></content>
      <categories>
        <category>Cheat-Sheet</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat缓存问题]]></title>
    <url>%2F2017%2F03%2F09%2Fdeal-tomcat-cache-clean%2F</url>
    <content type="text"><![CDATA[前言今天在做系统测试的时候，A登录测试网址http://xx.xx.xx.1的时候，在某个页面死活查询不出数据。而我本地登录http://xx.xx.xx.2的时候，可以很轻松的查询到数据。通过一系列的排除，最后发现是tomcat这小伙顽皮了。 发现问题测试人员A登录部署在服务器的网站http://xx.xx.xx.1，然后打开某个页面，然后点击查询，没有查询到数据。而我用本地连接相同库的项目，启动后，打开网页http://xx.xx.xx.2可以查询出数据，我把我的情况告诉了A。 分析问题排除浏览器缓存 我们的聪明的测试A，马上想到了会不会是浏览器缓存问题，她马上重置了浏览器缓存，结果奇迹没有发生。 我们的测试A为了排除自己浏览器的问题，又找了测试B，进行了同样的操作，也没查询出数据 排除代码不一致性 我将我本地的项目重新打包，然后远程登录服务器，将原来的项目重命名，然后把重新生成的包部署到tomcat上。然后我在我本地登录http://xx.xx.xx.1，竟然还是没有数据 排除tomcat缓存排除了浏览器缓存，和代码不一致性，那问题很清楚了，那就是tomcat的问题。这种问题，一般都是tomcat缓存导致的。 解决问题 我再次远程进入服务器，进入tomcat安装根目录。 删除/work/Catalina/localhost/下的全部文件 又删除了/temp/下的全部文件 然后我接着执行/bin/startup.bat 最后我在打开http://xx.xx.xx.1，问题解决了]]></content>
      <categories>
        <category>Deal-Problem</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录生活每一天]]></title>
    <url>%2F2017%2F03%2F08%2Frecord-everyday%2F</url>
    <content type="text"><![CDATA[前言本篇文章会记录自己生活，保证每天都会更新。 20170320170308因为昨天跑了步，流了汗，然后洗了头，洗了澡。晚上本来想暂停一晚先不跑，后来想想，因为闲洗澡麻烦而放弃健身，这理由我自己都觉得牵强，然后又换了衣服，跑步去了。 20170309晚上和进哥来找室友，和他聊和下天。他问了我面向过程和面向对象的区别。我举了一个例子：就是我从房间走到阳台的过程。如果是面向过程的话：就是我走到移门前，然后用手推开门，最后再走到阳台。如果是面向对象的话：首先我知道移门自己开和自己关的功能，我走移门前，移门自己把自己移开了，然后我走到阳台上。它们的区别就是，我只关心自己走到阳台这个目的，我不关心在我前面的是移门，是墙，还是刀山或火海。 20170310晚上和同事吃饭的时候，因为公司组织了明天与其他公司的联谊活动，大部人都参加了。同事问我咋不过去玩玩，我说我的另一半在教堂，也希望我以后的孩子可以安安静静的做一名基督徒。哈哈，这或许就叫做信仰歧视吧。 20170311晚上想起一个资料，记得之前保存在浏览器的收藏夹里。不过我忘记了是公司电脑，还是自己的笔记本，还是在我的云笔记上。找了好久，还是没找到，我看了下chrome上的书签，竟然有这么多。而大部分书签，在之后的日子里根本没用过。然后我就开始删除书签，删，删。不过有些确实挺不错的，最后选择了个这种的方式，将有用的内容整理到自己的知识构造里。哈哈，接下来有的忙了。 20170312晚上在整理之前写的笔记的时候，发现好多是技术使用方面的笔记。而我大部分的学习都是从网上其他人的文章上学习到的。这些类似使用手册的文章，网上很多人都有写过，我为什么自己还要重头写一遍。想了一下，还是选择一个更高效的方式，在优秀的文章上补充。突然发现，给自己省出了好多时间。 20170313晚上在想今天该写篇什么文章，本来想写io，然后又发现之前设计模式还没写好。在网上找io资料，心里想着设计模式，到最后什么都没写成。写东西这件事，还是单线程比较合适。 20170314晚上来办公室，本来想把多线程下载程序调通，最后遇到了个奇怪问题，调试了半天，还是没有解决。学习这件事，有个可以交流的人很重要。 20170315晚上本来想再继续写一篇bytecode的文章的，后来被国外的一篇文章吸引。这篇文章的把每个知识点讲的，估计连小孩子都可以理解。这就是水平。不是有句话话说：怎么证明自己明白了这个知识点，用最通俗易懂的话来解释，不断精炼，连小孩子都可以理解的话。 20170316这段时间一直在看技术书，发现代码写多了，连做梦都在写代码。晚上尝试下，干点其他事情，刚刚上传买了成甲老师的知识管理在线视频，晚上听听如何。有时候，一直喝鸡汤会中毒的，但是不喝鸡汤是万万不可的。 20170317晚上，继续在整理笔记的时候，发现这个博客又成了我的一个收集箱，什么东西都往里面扔。我已经有有道，为知，博客园，难道我搭建这个网站的目的是让他成为一个Collection。不是这样的，我有太多工具在收集资料了，这个博客应该成为一个OutPutStream那样的东西。本这这个目的，我把一些文章该删的删，以后只发原创。即便是转载，也会在转载的基础上扩展。 20170318晚上部门聚餐，地点小江南，来人15人。饭后格莱美，三人有事先回去。 20170319昨天失眠了，不过早上还是被7点50闹钟叫醒了。出门，吃了奶黄包+肉包+豆腐脑。本来想打车过去，看看没下雨。然后就找了量小黄车，骑了25分钟，到达磐石堂。找了个位置，安安静静的做下来。看到了熟人，这周陈燕在领唱诗歌。教了清心的人，唱了这条路上我们一起走和我需要有你在我生命中。接着神的仆人孙雅各分享了安守本位，虽然很困，但听我的精神抖擞。看圣经这么多年，到今天才知道。在索多玛面前，并不是亚伯拉罕比上帝更仁慈；也不是摩西比耶和华更仁慈。乃是，神把这件事告诉你，想看你对这件事的看法是怎么样。 20170321 晚上出去跑步的时候，突然想到了几句话。 送个HR的MM的已经话：招人就像玩俄罗斯套娃一样，新来的人如果比部门的平均水平要插，那么部门的整体水平就向最小的套娃更接近了。 送给Department Manager的一句话：每个月都要对你的下属有一次一对一的交流，你期望自己成为什么样的人，这个月你做了哪些努力。 送个Project Manager的一句话：懂点技术还是需要的，要不你怎么管理开发。 送给刚入职场的小白的一句话：学会发邮件真的很重要。 送给我自己的一句话：这年代从来不缺管理，缺少的是某个领域的专家。 20170322突然发现，白天一直被琐事打扰，一直不能几种注意力。要么改变自己，要不改变环境。 20170324晚上花了一小时，了解了MyBatis，写了几个Demo。原来在脑子清醒的时候，学东西是那么轻松。最后给做IT的自己一个建议：入门一门技术的门槛越来越低了，你可以轻松学会，别人也可以。但是要深入了解源码，你觉得很困难，别人也会很困难。当你从源码层面理解了，那就是你比别人的优势 20170325今天大学寝室聚会 20170325因为昨天发现除了我，他们都在玩同一款游戏阴阳师，然后晚上下载了这款游戏。这年头，没有一款共同的游戏，都没有共同语言了。 20170326其实有些东西还是靠背的，就比如概念。 20170327找到一种学习的新方式，直接从做题目开始 20170328今天发现了几个不错的英文技术网站，感觉可以转载一些文章过来 20170330今天陪客户喝了点小酒，然后会酒店退了房，打车去了火车站，在火车出发前5分钟上了车，到了目的地，取了票，做了地铁，上了一个哈尔滨的师傅的出租车。 20170331今天把为知笔记比较上的几篇之前的记录，上传了。我还是先把自己会的东西整理出来吧，之后在把在学的贴上去。 20170401今天上完班，就有大长假了，开心。 20170402今天和同事一起去了磐石堂。 主题:我把我所有的给你 证道人：胡泉源牧师 经文:徒：3：1-26 感悟：我所有的不是自己的能力和虔诚，乃是主所赐的信息 20170403晚上和室友一起看人民的名义，一句话：我有很多钱，但是我不敢用，因为这些钱不属于我 20170404玩了几把王者荣耀，看了下自己的好友，发现好多人玩的好疯狂，到凌晨2点多了，还在玩。 20170405今天开始上班，发现清明这几天，啥事都没干 20170406王者荣耀真不是一个好东西，第一次下班回来，玩了两把 20170407自从在清明那几天，把GitHub连击断了之后，就感觉无所谓了。习惯这东西还是不能停。 20170408早上一起来，被告知周一出差。马上联系了对方客户，了解了此行的目的，查了路线，买了一张机票，两张高铁票，约了司机。 20170409之前GitHub中断一个很大的原因是，公司笔记本的git提交不了了，然后也懒的弄。而自己笔记本的代码与GitHub上又不是一直的，也懒的上传。今天花了点时间，完成了源代码管理，也把占用我看书时间的王者荣耀卸载了。 20170410 6：45闹钟响起，洗了头，吃了昨晚买的干粮，7点准时出门 7：15坐上了，昨晚预约的徐师傅的出租车 7：39到达萧山机场，走的是九堡大桥 到中国国航取了机票，然后到自助机取了行程单 8：45在安检处检票 9：00上机，CA1907起飞时间9：25 9:45飞机起飞，因为暴雨原因延迟了（还好机智如我，已经把这个风险考虑进去了） 12：30到达长春龙嘉机场 12：45到达龙嘉高铁站 13：46在龙嘉站坐上了C1216动车，目的地长春，（还好我在8号那天考虑了各种可能风险，买对了票） 14:01到达长春，然后一路小跑到检票口 14:32从长春做上了C1021动车，目的地延吉西 16:45到达延吉西，这一路上在听罗永浩与罗振宇的长谈 17:00出站，坐上了客户的车，去吃饭先 原来朝鲜族的人特别喜欢吃辣，还记得几个才：牛舌拌牛肉，黄瓜干炒回锅肉，其他菜名字叫不来了 本来想出去逛逛，一出去，冻出翔了，马上回去上厕所 晚上leader打电话交流季度绩效 听了下徐老师的音频，某个领域的学习 20170424不知道是什么原因断了之后，然后就懒的在每天更新了。这东西还是不能断了。今天晚上出去跑了下步，然后回来整理了下SpringBoot相关的笔记，然后看了下孤独大脑的文章，如此而已。 20170425早上做需求变更的时候，学到了新东西，就是写卡失败的时候，直接作废租赁费。中午回去洗了下几件短袖和一件衬衫。晚上回去学习了SpringBoot的一些知识 20170426早上复习了写SpringMVC的各个知识点，温故知新。中午回去刷了下朋友圈。下午在维护一个客户问题时，有点火大。 20170429今天天气不错，可以换被子了。把薄被子和厚被子都拿出去晒了下。 20170430还是好天气，把四双鞋子都拿出去晒了下 20170501今天天气天气不算晴，没有昨天的火辣，还好昨天机制把鞋子洗了，要是今天洗的话肯定干不了。有些东西错过了，就错过了，没有如果。 20170502晚上加班了，从17:30加班到20:00。不过对Tomcat更了解了一步(temp) 20170503晚上参加了USmart的培训，只在一个页面上操作，挺不错的。准备下，明天出差。 20170504 杭州上午天气晴，看手机下午好像下雨了 6点58的闹钟，起床，洗头，刷牙，洗脸，涂保湿液，整理行囊，收拾被褥，吃早餐，取现金 8点上了徐师傅的车，走的是九堡大桥 8点30到达萧山机场，春秋航班9C8556(10:20-12:30，竟然没有提供午餐和水，坑爹)，柜台取票，无法去行程单选择邮寄 12:05达到石家庄保定机场，做黑车直奔正定机场站(机场大巴半小时一班)，取票，时间充足，吃泡面 13点26上了前往邯郸东的G67（13:26-14:34） 14:37出站，买瓶水换取7个硬币，往汽车站出发 15:10新1路从高铁公交北站出发，目的地左西村站 坑爹司机让我提早下站了，百度地图，有距离，做顺风车到新一中站 16:13做802目的地磁县二环路口站 16:41闭目养神坐过站，忙下车 上了前往邯郸的顺风车冀D.79IKH，半路中拉到两客，我下车，未收钱，谢别 百度地图，一路步行，确认客户位置，美团，一路步行，住宿，终于可以吃饭了 与客户确认到场，跟老妈报告平安 看海贼，睡觉，听音乐，写此文章 一句话绑定今天：一天没吃饭，一路黑车，步行2小时，到处飘着霾，一切平安。两个字，感谢神。 20170505 7点30闹钟，起床，吃早餐 步行20分钟，到达客户公司 打电话，进入，两个窗口 收集需要的资料，回去 电话处理客户问题，延吉+京山 修改脚本，核对数据 一句话绑定：晚上真不应该花40分钟玩王者荣耀，因为它导致了后面一连串的浪费 20170506 8点30起床，刷牙，洗脸，烧开水，喝水充饥 整理Gradle笔记，做Oracle数据库转SqlServer，看还在海贼漫画 发现一个吃饭的好地方，冲了卡 去超市买了点吃的，小面包，果冻，酸奶，益达 重写迁移脚本，使其颗粒度更加小，更易排除异常 20170507我已经上床关灯睡觉一回了，突然想起今天还没提交git。然后又起床，开电脑，写了这个。 早上吃了干面包+白开水 中午吃了排骨面 晚上吃了羊肉炒饭 今天去了趟客户公司 晚上Visual Box连接不到本机，吓坏宝宝了，因为Oracle装在虚拟机里面。 20170508乔布斯真的很厉害，即便所有人都发对他，依然坚信自己选择的方向是适合苹果的。 8点30起床，喝水充饥，改脚本，测数据 1点吃了烧饼（猪肉韭菜9块+鸡蛋汤3块），睡觉 2点去燃气公司，结果他们2点30才上班 核对数据，测试上表，有问题，联系人 拿表回酒店，测试 晚上吃了羊肉拉面（大份的8块） 吃了根火腿，茶叶蛋，果冻。发现自己吃果冻吃上瘾了 20170509 看完乔布斯传这本书，值得读第二遍 模拟新表，模拟旧表，一切顺利 寻找真实用户测试 转Oracle的时候，又出问题了，不过感谢神最终都解决了 别问我过程，我只想知道结果 20170510晚上系统终于上线了，终于可以好好睡一觉了，感谢主 20170511上线第一天，一切顺利，感谢主 20170512上午去客户公司，做最后收尾工作，以及讨论后期工作 20170513 准备回杭州，愿上帝保守我平安。正如保守我平平安安的来，也能平平安安的回。 更新了插件后，原来的功能有问题了，坑爹，发布程序后也不测试一下 发现周星驰、乔布斯、罗永浩都挺像的，很偏执，很看重细节，工作更重与一切。 20170515整理了下JVM的代码 20170515晚上出去跑步了 20170516如果有一天我不再写代码了，我真想去当一回传道人。 20170517今天联系了下口语，如果我不改变自己的习惯，不提升自己的自制力，即便时间可以重来，我估计还是现在的自己。 20170518天气多云，微热。晚上花了2小时参加一个所谓的培训会，我只能说呵呵。会后去散散步，想通了一个问题：存在即合理。为什么路上有人在骑车，有人跑步，有人散步，因为这是健身的不同方式。多角度看问题，骑车时突然刹车，因为前面有故障。 20170529今天买了好多运动装备。20kg哑铃，100LB握力器，环形腕力器，脚蹬器，俯卧撑支架。两套吸汗运动服。 20170531以后晚上回来不玩电脑，必定有运动一项。 20170601因为Mysql转Sqlserver的失败，无意间竟然理出了一套通用数据迁移方案。晚上的完成运动项目：两组指力训练(一组10个)，四组腕力训练(一组10个)，一组俯卧撑(一组10个)，一组深蹲(一组10个)，四组哑铃(一组10个)，传媒操场40分钟跑步。 20170602看了电影《摔跤吧 爸爸》 20170603成功是由每天的坚持组成的，而堕落则是某一天的懈怠导致的。–今天断了某个计划 20170604早上去了磐石堂，中午去电影院看了加勒比海盗5。磐石堂分享经文：对生命之道的几种反应。经文：徒5:12-42 以公会为代表的见证 以使徒为代表的见证 以迦玛列为代表的见证 以教会为代表的追随 电影后感：读书真的会改变命运。若女主不爱读书，就不会有这部电影。 20170609晚上学习了下IDEA 20170611今天手机刷机忘记备份了两样东西：跑步记录；知识网盘地址 20170615今天室友搬出去了，一个人的时候，总会想很多，这获取就叫孤独吧。 20170617今天我回家了 20170630今天出差甘肃玉门，先到达兰州，再到嘉峪关。嘉峪关机场下车到嘉峪关南站。嘉峪关南站到玉门站。]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【02】Java虚拟机结构]]></title>
    <url>%2F2017%2F03%2F08%2Fbook-jvm-002%2F</url>
    <content type="text"><![CDATA[前言Java虚拟机规范中没有明确描述实现细节，设计者可以自主决定所有规范中不曾描述的虚拟机内部细节。例如：运行时数据区的内存如何布局、选用哪种垃圾收集的算法、是否要对虚拟机字节码指令进行一些内部优化操作。 Class文件格式编译后被Java虚拟机所执行的代码使用了一种平台中立的二进制格式来表示，并且经常以文本的形式存储，因为这种格式被称为Class文件格式。 Class文件格式中精确地定义了类与接口的表示形式，包括平台相关的目标文件格式中一些细节上的惯例，如字节序。 平台相关的目标文件格式是指在特定平台编译出的Class文件无法在其他平台中使用。 数据类型Java虚拟机可以操作的数据类型可分为两类：原始类型和引用类型。与之对应，也存在原始值(Primitive Values)和引用值(Reference Values)两种类型的数值。 Java虚拟机希望尽可能多的类型检查在程序运行之前完成，换句话说，编译器应当在编译期间尽最大努力完成可能的类型检查，使得虚拟机在运行期间无需进行这些操作。 虚拟机的字节码指令本身可以确定它的指令操作数的类型是什么，可以利用这种特性可直接确定操作数的数值类型。例如：iadd，ladd，fadd和dadd这几条两个数值相加指令专属操作数类型分别为：int，long，float，double。 虚拟机中使用reference类型来表示对某个对象的引用。 reference是引用类型(Reference Types)的一种，int，long，double是原始类型（Primitive Types）的一种。 reference,int,long,double是具体的数据类型，Reference Types，Primitive是某种数据类型的统称。 原始类型与值Java虚拟机支持的原始数据类型包括数值类型(Numeric Types)，布尔类型(Boolean Types)，returnAddress类型三类。 数值类型又分为整型类型(Integral Types)和浮点类型(Floating-Point Types)两种。 整型类型与整型值 byte，1个字节，默认值0， short，2个字节，默认值0 int，4个字节，默认值0 long，6个字节，默认值0 char，2个字节，默认值null 浮点类型、取值集合及浮点值 float，32位单精度，默认值正数0 double，64位双精度，默认值正数0 除了NaN之外，浮点数集合中的元素都是有序的 浮点数中，整数零和负数零是相等的 returnAddress类型和值 returnAddress类型会被Java虚拟机的jsr、ret和jst_w指令所使用。 returnAddress类型的值指向一条虚拟机指令的操作码。 boolean类型 在Java语言之中涉及到boolean类型值的运算，在编译之后都使用Java虚拟机中的int数据类型来代替 虚拟机的newarray指令可以创建boolean数组 引用类型与值 Java虚拟机中有三种引用类型：类类型(Class Types)，数组类型(Array Tyeps)和接口类型(Interface Types)。这些引用类型的值分别由类实例、数组实例和实现了某个接口的类实例或数组实例动态创建。 数组类型包括一个单一维度的组件类型(Component Type)，一个数组的组件类型也可以是数组。 数组的元素类型(Element Type)必须是原始类型、类类型或者接口类型之中的一种。 引用类型默认值就是null Java虚拟机规范并没有规定null在虚拟机实现中应当怎样编码表示 运行时数据区PC寄存器 每一条Java虚拟机线程都有自己的PC(Program Counter)寄存器 在任意时刻，一条Java虚拟机线程只会执行一个方法的代码，这个方法称为该线程的当前方法(Current Method) 如果该方法不是native的，那PC寄存器就保存Java虚拟机正在执行的字节码指令的地址 如果该方法是native的，那么PC寄存器的值是undefined PC寄存器的容量至少应当保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值 Java虚拟机栈 每一条Java虚拟机线程都有自己私有的Java虚拟机栈(Java Virtual Machine Stack)，这个栈与线程同时创建，用于存储栈帧(Frames)。 Java虚拟机栈的作用是用于存储局部变量和一些过程结果的地方 Java堆 堆(Heap)是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域 Java堆在虚拟机启动的时候就被创建，他存储了被自动管理系统所管理的各种对象，这些受管理的对象无需，也无法显示地被销毁。 自动管理系统(Automatic Storage Management System)，也即常说的垃圾收集器(Garbage Collector)。 方法区 方法区(Method Area)是可供各条线程共享的运行时内存区域。 方法区存储了每一个类的结构信息，例如：运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。 方法区在虚拟机启动的时候被创建 运行时常量池 运行时常量池(Runtime Constant Pool)是每一个类或接口的常量池(Constant_Pool)的运行时表示形式，它包括了若干种不同的常量。 每一个运行时常量池都分配在Java虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量就被创建出来。 本地方法栈 Java虚拟机实现可能会使用到传统的栈来支持native方法的执行，这个栈就是本地方法栈(Native Method Stack)。 传统的栈又称C Stacks native方法指使用Java以外的其他语言编写的方法 栈帧 栈帧(Frame)是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、方法返回值和异常分派(Dispatch Exception)。 栈帧随着方法调用而创建，随着方法结束而销毁。 栈帧容量的大小取决于Java虚拟机的实现和方法调用时可被分配的内存 在一条线程之中，只有目前正在执行的那个方法的栈帧是活动的，这个栈帧被称为当前栈帧(Current Frame)，这个栈帧对应的方法被称为当前方法(Current Method)，定义这个方法的类被称作当前类。 当一个新的方法被调用，一个新的栈帧也会随之而创建，并且随着程序控制权移交到新的方法而成为新的当前栈帧。 栈帧是线程本地私有的数据，不可能在一个栈帧之中引用另外一条程序的栈帧 局部变量表 每个栈帧内部都包含一组称为局部变量表(Local Variables)的变量列表。 boolean、byte、char、short、float、reference占一个局部变量 long、double占两个连续的局部变量 Java虚拟机使用局部变量表来完成方法调用时的参数传递 当实例方法别调用的时候，第0个局部变量一定是用来存储被调用实例方法所在的对象的引用(即this) 操作数栈 每一个栈帧内部都包含一个操作数栈 Java虚拟机提供一些字节码指令来从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中，也提供一些指令用于从操作数栈取走数据、操作数据和把操作结果重新入栈。 动态链接 每一个栈帧内部都包含一个指向运行时常量池的引用来支持当前方法代码实现动态链接(Dynamic Linking) 在Class文件里面，描述一个方法调用了其他方法，或者访问其成员变量是通过符号引用(Symbolic Reference)来表示的。 动态链接的作用就是将这些符号引用所表示的方法转换为实际方法的直接引用。 方法正常调用完成 方法正常调用完成是指在方法的执行过程中，没有任何异常被跑出。 如果当前方法调用正常完成的话，它很可能会返回一个值给调用它的方法。 方法异常调用完成 方法异常调用是指在方法的执行过程中，某些指令导致了Java虚拟机抛出异常 如果方法异常调用完成，那一定不会有方法返回值返回给它的调用者 对象的表示 Java虚拟机规范不强制规定对象的内部结构应当如何表示 浮点算法Java虚拟机和IEEE 754的浮点算法 在Java虚拟机中的浮点数在遇到非法操作，如被零除、上限溢出、下限溢出和非精确时，不会抛出exception 浮点模式 每一个方法都有一项属性称为浮点模式(Floating-Point Mode)，取值有两种，要么是FP-strict模式要么是非FP-strict模式。 方法的浮点模式决定于Class文件中代表该方法的method_info结构的访问标志(access_flags)中的ACC_STRICT标志位的取值。 数值集合转换 在一些特定场景下，支持扩展指数集合的Java虚拟机实现数值在标准浮点数集合与扩展指数集合之间的应收关系是运行和必要的，这种映射操作就称为数值集合转换。 数值集合转换并非数据类型转换，而是在同一种数据类型之中不同数值集合的映射操作。 初始化方法的特殊命名 在Java虚拟机层面上，Java语言中的构造函数是以一个名为的特殊实例初始化方法的形式出现的，这个方法名称是由编译器命名的，因为它是一个非法的Java方法命名。 一个类或者接口最多可以包含不超过一个类或接口的初始化方法，类或者接口就是通过这个方法完成初始化的。这个方法是一个不包含参数的静态方法，名为。这个名字也是有编译器命名的。 异常 Java虚拟机里面的异常使用Throwable或其子类的实例来表示，抛异常的本质实际上是程序控制权的一种即时的、非局部(Nonlocal)的转换—从异常抛出的地方转换至处理异常的地方。 在Class文件中定义了明确的异常处理器查找顺序，才能保证无论Class文件是通过何种途径产生的，Java虚拟机执行时都有一致的行为表现。 字节码指令集简介 Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码(Opcode)以及跟随其后的零至多个代表此操作所需参数的操作数(Operands)所构成。 如果一个操作数的长度超过一个字节，那它将会以Big-Endian顺序存储–即高位在前的字节序。 数据类型与Java虚拟机 在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。 大部分与数据类型相关的字节码指令，他们的操作助记符中都有特殊的字符来表面专门为哪种数据类型服务：i代码对int类型的操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。 一些指令的助记符中没有明确的指明操作类型的字母，如：arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。无条件跳转指令goto则是与数据类型无关的。 大部分的执行都没有支持整数类型byte、char、short、boolean。实际上都是使用相应的int类型作运算类型(Compulational Type) 编译器会在编译期或运行期会将byte和short类型的数据带符号扩展(Sign-Extend)为相应的int类型 编译器会将boolean和char类型数据零位扩展(Zero-Extend)为相应的int类型数据 在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字符码指令来处理 加载和存储指令 加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传输 将一个局部变量加载到操纵栈的指令包括：iload、iload_、lload… 将一个数值从操作数栈存储到局部变量表的指令包括：istore、istore_、lstore… 将一个常量加载到操作数栈的指令包括有：bipush、sipush、ldc… 扩充局部变量表的访问索引的指令：wide iload_，它代表了iload_0，iload_1，iload_2，iload_3这几条指令，他们表面上没有操作数，但操作数都是在指令隐含了 运算指令 算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。 运算指令分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令，它们都是使用Java虚拟机的数字类型。 所有算术指令如下表格 指令名称 指令代码 加法指令 iadd，ladd，fadd，dadd 减法指令 isub，lsub，fsub，dsub 乘法指令 imul，lmul，fmul，dmul 除法指令 idiv，ldiv，fdiv，ddiv 求余指令 irem，lrem，frem，drem 取反指令 ineg，lneg，fneg，dneg 位移指令 ishl，ishr，iushr，lshl，lshr，lushr 按位或指令 ior，lor 按位与指令 iand，land 按位异或指令 ixor，lxor 局部变量自增指令 iinc 比较指令 dcmpg，dcmpl，fcmpg，fcmpl，lcmp 类型转换指令 类型转换指令可以将两种Java虚拟机数值类型进行相互转换，这些转换操作一般用于实现用户代码的显式类型转换操作，或者用来处理Java虚拟机字节码指令集中指令非完全独立的问题 Java虚拟机直接支持以下数值的宽化类型转换(Widening Numeric Conversions) 直接支持即转换时无需显示的转换指令；宽化类型转换即小范围类型向大范围类型的安全转换 int类型到long、float、double long类型到float、double float类型到double 窄化类型转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2f 窄话类型转换可能会导致转换结果产生不同发正负号、不同的数量级，转换过程很可能会导致数值数据丢失精度 尽管可能发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机中数值类型的窄化转换永远不可能导致虚拟机抛出运行时异常。该异常指《Java虚拟机规范》中定义的异常。 对象创建与操作 创建类实例的指令：new 创建数组的指令：newarray，anewarray，multianewarray 访问类字段(static，类变量)和实例字段(非static，实例类型)的指令：getfield，putfield，getstatic，putstatic 把一个数组元素加载到操作数栈的指令：baload，caload，saload，iaload，laload，faload，daload，aaload 将一个操作数栈的值储存到数组元素中的指令：bastore，castore，sastore，iastore，fastore，dastore，aastore 取数组长度的指令：arraylength 检查类实例类型的指令：instanceof，checkcast 操作数栈管理指令 Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：pop，pop2，dup，dup2，dup_xl，dup2_xl，dup_x2，dup2_x2，swap 控制转移指令 控制转换指令可以让Java虚拟机有条件或无条件地从指定指令而不是控制转移指令的下一条指令继续执行程序。 控制转移指令包括：条件分支，复合条件分支，无条件分支 条件分支：ireq、iflt、ifle、ifne… 复合条件分支：tableswitch、lookupswitch 无条件分支：goto、goto_w、jsr、jsr_w、ret boolean、byte、char、short类型的条件分支比较操作，都使用int类型的比较指令来完成 long、float、double类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后在执行int类型的条件分支比较操作来完成整个分支跳转 Java虚拟机提供了丰富的int类型的条件分支指令 方法调用和返回指令 invokevirtual指令用于调用对象的实例方法 invokeinterface指令用于调用接口方法 invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法 invokestatic指令用于调用类方法(static方法) 方法的返回指令是根据返回值的类型区分的，包括ireturn(返回值是boolean、byte、char、short、int)、lreturn、freturn、dreturn、areturn。return指令供声明为void方法、实例初始化方法、类和接口的类初始化方法使用 抛出异常 在程序中显示抛出异常的操作会由athrow指令实现 同步 Java虚拟机可以支持方法级别的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程(Monitor)来支持的 虚拟机可以从方法常量池中的方法表结构(method_info Structure)中的ACC_SYNCHRONIZED访问标志区分一个方法是否同步方法 同步一段指令集序列通常是有Java语言中的synchronized块来表示的，Java虚拟机的指令集有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要编译器与Java虚拟机两者协作支持 结构话锁定(Structured Locking)是指在方法调用期间每一个管程退出都与前面的管程进入相匹配的情形。 类库 Java虚拟机必须对不同平台下Java类库的实现提供充分的支持，因为其中有一些类库如果没有Java虚拟机的支持的话是根本无法实现的 公有设计，私有实现 Java虚拟机共同外观：Class文件格式以及字节码指令集等。这些内容与硬件、操作系统和Java虚拟机的独立实现都是密切相关的，虚拟机实现者可能更愿意把它们看作是程序在各种Java平台实现之间互相安全地交互的手段，而多于一张需要精确跟随的计划蓝图。 Java虚拟机实现的方式主要有两种 将输入的Java虚拟机代码在加载时或执行时反应成另一中虚拟机的指令集 将输入的Java虚拟机代码在加载时或执行时翻译成宿主主机CPU的本地指令集(JIT)]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat内存溢出]]></title>
    <url>%2F2017%2F03%2F08%2Fdeal-tomcat-out-of-memory-error%2F</url>
    <content type="text"><![CDATA[前言今天运行一个web项目的时候，在点击页面的时候，显示特别慢，而且经常直接在后台出错了，经过百度谷歌之后，原来是JVM内存溢出，需要配置几个参数优化下。 问题描述123456789101112严重: Servlet.service() for servlet WorkOrderPreview threw exceptionjava.lang.OutOfMemoryError: PermGen space at sun.misc.Unsafe.defineClass(Native Method) at sun.reflect.ClassDefiner.defineClass(Unknown Source) at sun.reflect.MethodAccessorGenerator$1.run(Unknown Source) at sun.reflect.MethodAccessorGenerator$1.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at sun.reflect.MethodAccessorGenerator.generate(Unknown Source) at sun.reflect.MethodAccessorGenerator.generateMethod(Unknown Source) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) 马上注意到了错误描述中的几个关键词java.lang.OutOfMemoryError以及PermGen space 解决问题我的操作是进入Run–&gt;Run Configurations–&gt;Tomcat v6.0 Server–&gt;Arguments–&gt;VM arguments在最结尾添加一下内容 1-Xms256m -Xmx512m -XX:PermSize=256m -XX:MaxPermSize=256m -Duser.timezone=GMT+08]]></content>
      <categories>
        <category>Deal-Problem</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat启动失败]]></title>
    <url>%2F2017%2F03%2F07%2Fdeal-tomcat-faild-to-start%2F</url>
    <content type="text"><![CDATA[前言昨天tomcat突然启动不起来了，又是看log，又是改端口，最后发现竟然是host的问题，此文就记录一下我排除问题的过程 tomcat报错了错误信息 错误描述1234567891011121314151617严重: StandardServer.await: create[localhost:8005]: java.net.BindException: Cannot assign requested address: JVM_Bind at java.net.DualStackPlainSocketImpl.bind0(Native Method) at java.net.DualStackPlainSocketImpl.socketBind(Unknown Source) at java.net.AbstractPlainSocketImpl.bind(Unknown Source) at java.net.PlainSocketImpl.bind(Unknown Source) at java.net.ServerSocket.bind(Unknown Source) at java.net.ServerSocket.&lt;init&gt;(Unknown Source) at org.apache.catalina.core.StandardServer.await(StandardServer.java:427) at org.apache.catalina.startup.Catalina.await(Catalina.java:777) at org.apache.catalina.startup.Catalina.start(Catalina.java:723) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:321) at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:455) 排查tomcat问题我打开了Tomcat的安装跟目录，进入logs文件夹，竟然没有任何日志 排除端口问题当我看到了JVM_Bind和localhost:8005第一反应是，8005端口被其他应用程序占用了。我看看到底哪个程序占用了我们tomcat通讯。我在dos界面下输入netstat -ano就看到了所有端口使用情况，仔细看了下，竟然没发现8005端口。 1234567891011121314活动连接 协议 本地地址 外部地址 状态 PID TCP 0.0.0.0:21 0.0.0.0:0 LISTENING 2280 TCP 0.0.0.0:80 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:135 0.0.0.0:0 LISTENING 1004 TCP 0.0.0.0:443 0.0.0.0:0 LISTENING 5612 TCP 0.0.0.0:444 0.0.0.0:0 LISTENING 4284 TCP 0.0.0.0:445 0.0.0.0:0 LISTENING 4 TCP 0.0.0.0:554 0.0.0.0:0 LISTENING 10804 TCP 0.0.0.0:902 0.0.0.0:0 LISTENING 4584 TCP 0.0.0.0:912 0.0.0.0:0 LISTENING 4584 TCP 0.0.0.0:1026 0.0.0.0:0 LISTENING 564 TCP 0.0.0.0:1028 0.0.0.0:0 LISTENING 1232 不死心，在我做了telnet 127.0.0.1 8005之后，彻底死心 12λ telnet 127.0.0.1 8005 正在连接127.0.0.1...无法打开到主机的连接。 在端口 8005: 连接失败 排除ip问题既然不是端口问题，那会不会是ip问题，我马上想到了host文件。打开了C:\Windows\System32\drivers\etc，发现了一个奇怪的指向localhost的ip（这个ip已经被我改过了）。 123# Localhost (DO NOT REMOVE)127.0.0.1 localhost100.30.5.2 localhost 那我就把这条解析删除了，试试。删除之后，我运行ipconfig /flushdns刷新了host。 123λ ipconfig /flushdns Windows IP 配置 已成功刷新 DNS 解析缓存。 问题解决了然后我在运行了下tomcat，竟然成功了。原来是host惹的祸]]></content>
      <categories>
        <category>Deal-Problem</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo博客]]></title>
    <url>%2F2017%2F03%2F04%2Fcheat-sheet-build-hexo-blog%2F</url>
    <content type="text"><![CDATA[前言本站点采用的是Hexo博客框架，使用的主题的Next主题，如果你也喜欢该主题，可以按照以下操作搭建自己的博客。 Github注册Github官网：https://github.com/ 注册的时候没什么特别的地方，一直下一步下一步。注册好之后会提示你验证邮箱，如果邮箱里面没收到，看看是不是被黑名单拦截了。 注册好之后，在Github上新建一个仓储，名字叫做your_github_name.github.io,其中your_github_name是你Github的用户名 Git安装Git官网：https://git-scm.com/ 我使用的是64位的Windows操作系统，Windows用户下载地址：https://git-scm.com/download/win 安装好之后需要配置一下你的本地Git： 验证Git是否安装成功1git version 如果可以看到你本地Git信息，说明Git安装成功了 配置本地Git环境12$ git config --global user.name "your_github_name"$ git config --global user.email "your_email@example.com" your_github_name是你Github的用户名，your_email@example.com是你注册Github绑定的邮箱 配置SSH Key检查SSH keys 1cd ~/. ssh 如果返回No such file or directory则表示你未配置ssh key。 如果没有返回上面提示，而是直接进入了默认目录，说明本机已经配置了SSH Key。你可以通过使用cd .ssh和ls查看本机配置的ssh keys 生成新的ssh key 不管你已经配置了，或者没有配置，你都可以重新生成新的SSH Key，方法如下 1$ ssh-keygen -t rsa -C "your_email@example.com" your_email@example.com是你注册Github绑定的邮箱 把ssh key添加到Github上 拷贝C:\Users\John.ssh\id_rsa.pub里面的内容；登录GitHub-&gt;Settings-&gt;SSH and GPG keys–&gt;New SSH key-&gt;Add SSH key；通过命令$ ssh -T git@github.com验证是否配置成功 Node.js安装Node.js官网：https://nodejs.org/en/ 你可以在dos中输入node -v来检查是否安装成功 Hexo安装如果我们已经安装好了Node.js和Git，那么我只需要使用npm即可完成Hexo的安装 1$ npm install -g hexo -cli 我们可以同时hexo version来验证hexo是否安装成功了 Hexo建站安装Hexo完成后，执行下列命令，Hexo讲会在指定文件夹中新建所需要的文件 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成后，指定文件夹的目录如下 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml：网站的配置信息，在本文中，我们会叫他站点配置文件 package.json：应用程序信息，可以看到hexo信息，即站点的依赖插件 scaffolds：模板文件夹，当我们新建文章时，Hexo会根据scaffold来建立文件。如果我们修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改 source：资源文件夹是存放用户资源的地方。Markdown和HTM文件会被解析并放到public文件夹，而其他文件会被拷贝过去。 themes：主题 文件夹。Hexo会根据主题来生成静态页面。 Hexo站点配置我们可以在站点配置文件中修改大部分的配置 网站1234567# Sitetitle: Think Differentsubtitle: description: kim is meauthor: Kimismelanguage: entimezone: Asia/Shanghai title：网站标题subtitle：网站副标题author：您的名字language：网站使用的语言timezone：网站时区，Hexo默认使用你电脑的时区 网址12345# URLurl: http://kimisme.comroot: /permalink: :year/:month/:day/:title/permalink_defaults: url：网址root：网站根目录permalink：文章的永久链接格式permalink_defaults：永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录123456789# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: source_dir：资源文件夹，这个文件夹用来存放内容。public_dir：公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir：标签文件夹archive_dir：归档文件夹category_dir：分类文件夹code_dir：Include code 文件夹i18n_dir：国际化（i18n）文件夹skip_render：跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示123456789101112131415# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: new_post_name：新文章的文件名称default_layout：预设布局auto_spacing：在中文和英文之间加入空格titlecase：把标题转换为 title caseexternal_link：在新标签中打开链接filename_case：把文件名称转换为 (1) 小写或 (2) 大写render_drafts：显示草稿post_asset_folder：启动 Asset 文件夹relative_link：把链接改为与根目录的相对位址future：显示未来的文章highlight：代码块的设置 分类&amp;标签1234# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map: default_category：默认分类category_map：分类别名tag_map：标签别名 日期/时间格式Hexo 使用 Moment.js 来解析和显示时间。 123# Date / Time formatdate_format: YYYY-MM-DDtime_format: HH:mm:ss date_format:日期格式time_format:时间格式 分页1234# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page per_page：每页显示的文章量 (0 = 关闭分页功能)pagination_dir：分页目录 扩展12345678# Extensionstheme: next# Deploymentdeploy: type: git repo: git@github.com:Kimisme/kimisme.github.io.git branch: master theme：当前主题名称。值为false时禁用主题deploy：部署部分的设置 此处的repo要写上你的，Github Page地址 运行网站运行我们的网站配置了站点信息，接下来让我们允许下网站。执行以下命令 12hexo ghexo s 然后我们在浏览器中输入http://localhost:4000就可以看到网站了。 Hexo中指令说明 hexo init myblog：新建一个文件夹并初始化hexohexo new “java-basic”：新建一篇文章hexo g：生成静态文件，它扩展出两种方式。hexo g -d文件生成后立即部署网站，hexo g -w监视文件变动hexo publish：发布草稿hexo s：启动服务器，它扩展出三种方式。hexo s -p 8081表示重设端口；hexo s -s表示只使用静态文件；hexo s -l表示启动日记记录，使用覆盖记录格式。hexo d：部署网站。hexo d -g表示部署之前预先生成静态文件hexo render ：渲染文件，参数-o设置输出路径hexo migrate ：从其他博客系统迁移内容hexo clean：清楚缓存文件(db.json)和已生成的静态文件(public)hexo list category：列出网站资料hexo version：显示Hexo版本 以下是一些可选项 hexo –safe：在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。hexo –debug：在终端中显示调试信息并记录到 debug.loghexo –silent：隐藏终端信息hexo –config custom.yml：自定义配置文件的路径，执行后将不再使用 _config.ymlhexo –draft：显示source/_drafts文件夹中的草稿文章hexo –cwd /path/to/cwd：自定义当前工作目录（Current working directory）的路径 将网站部署到Github首先我们按照部署插件 1npm install hexo-deployer-git --save 然后执行 12hexo ghexo d 如果不出错的话，你在浏览器中输入http://your_github_name.github.io就可以看到个人站点了 将网站与个人域名绑定注册一个自己的域名 获取你博客的ip 解析自己的域名 在kimisme.github.io仓库中添加自己的域名 配置主题我的博客采用的是Next主题，在主题根目录下themes/next/也有个_config.yml文件，我们称它为主题配置文件 安装必要插件1npm install hexo-util --save 配置主题在站点配置文件中配置主题 1theme: next 配置语言在站点配置文件中配置语言 1language: zh-Hans 配置菜单在主题配置文件中配置菜单 12345678menu: home: / categories: /categories about: /about archives: /archives tags: /tags #sitemap: /sitemap.xml commonweal: /404.html 配置头像在站点配置文件中配置头像 1avatar: http://om9xacvdp.bkt.clouddn.com/blog-self-logo.jpg 配置统计功能在站点配置文件中修改 1baidu_analytics: 1212122323223 配置阅读次数在主题配置文件中修改 123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 23232 app_key: 32323 友情链接在主题配置文件中修改 12345678# Blog rollslinks_title: Linkslinks_layout: block#links_layout: inlinelinks: 阮一峰: http://www.ruanyifeng.com/home.html 廖雪峰: http://www.liaoxuefeng.com/ Edison Chou: http://www.cnblogs.com/edisonchou/p/4820676.html 参考文章https://hexo.io/zh-cn/docs/ http://theme-next.iissnan.com/getting-started.html]]></content>
      <categories>
        <category>Cheat-Sheet</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown备忘录]]></title>
    <url>%2F2017%2F03%2F03%2Fcheat-sheet-markdown%2F</url>
    <content type="text"><![CDATA[前言本章主要记录Markdown的一些语法 标题方式一 方式二 列表 引用 粗体和斜体 链接和图片 分割线 表格 代码高亮 更多代码表请参考markdown代码表 语言 对应代码表 Bash bash, sh, zsh C# cs, csharp C++ cpp, c, cc, h, c++, h++, hpp CSS css DOS dos, bat, cmd HTML, XML xml, html, xhtml, rss, atom, xjb, xsd, xsl, plist JSON json Java java, jsp JavaScript javascript, js, jsx Objective C objectivec, mm, objc, obj-c PHP php, php3, php4, php5, php6 Ruby ruby, rb, gemspec, podspec, thor, irb SQL sql Swift swift VB.Net vbnet, vb 制作代办事项 流程图 序列图 甘特图 特殊符号 图片中的源码如下 1234567891011上标：n&lt;sup&gt;2&lt;/sup&gt;=n+1 下标：a=log&lt;sub&gt;2&lt;/sub&gt;b注册商标：立白&amp;reg;function符号：&amp;fnof;(x)=x+1根号：&amp;radic;5角度符号：30&amp;deg; 其他符号，请参考]]></content>
      <categories>
        <category>Cheat-Sheet</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么搭建博客]]></title>
    <url>%2F2017%2F03%2F02%2Frecord-why-build-blog%2F</url>
    <content type="text"><![CDATA[前言这是我在个人博客上发布的第一篇文章，作为是个里程碑记录下。 初衷搭建个人博客的想法，是我从大学三年级的时候开始的。在那一年的某一天，我在浏览网页的时候，无意中登录到了一个网站ttt.tt，这是一个基于WordPress的个人网站，里面记录了作者的分享。我感觉很酷，也想有一个这样的网站，不过当时也只能有一个想法。 一次机遇在我大四的时候，因为要做毕业设计，在找资料的过程中，发现了Bootstrap这东西，发现它做出来的网页非常炫酷。本来想在毕业设计中用到，无奈当时对技术自学能力不是很强，不过那时有了一个想法，我以后如果有自己的网站，我就要用Bootstrap。也就是在那时买了http://kimisme.com这个域名，那时万网搞活动，也就是在那时买了阿里云的虚拟主机。 空白期毕业后，虽然有搭建网站的想法，但是一直没投入任何时间在上面。虽然中间在做微信后台开发的时候用过虚拟主机。一直到现在，阿里云虚拟机主机，和两个域名一直没利用起来。 从0开始直到最近这段时间，在qq群里，听人说起Hexo这个博客框架。然后上网查了下，然后按照教程，没想到很整个过程非常顺利。前前后后就花了2个小时，就部署好了一个网站。 1的突破毕业后，每天都在学习，不过大部分都是以笔记的形式记录在云笔记上，接下来时间，期望是，把笔记整理下，然后开始输出。]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
</search>
